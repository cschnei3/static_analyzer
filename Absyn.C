//C++ Abstract Syntax Implementation generated by the BNF Converter.
#include <algorithm>
#include <string>
#include <iostream>
#include <vector>
#include "Absyn.H"

/********************   Progr    ********************/
Progr::Progr(ListExternal_declaration *p1)
{
  listexternal_declaration_ = p1;

}

Progr::Progr(const Progr & other)
{
  listexternal_declaration_ = other.listexternal_declaration_->clone();

}

Progr &Progr::operator=(const Progr & other)
{
  Progr tmp(other);
  swap(tmp);
  return *this;
}

void Progr::swap(Progr & other)
{
  std::swap(listexternal_declaration_, other.listexternal_declaration_);

}

Progr::~Progr()
{
  delete(listexternal_declaration_);

}

void Progr::accept(Visitor *v)
{
  v->visitProgr(this);
}

Progr *Progr::clone() const
{
  return new Progr(*this);
}



/********************   Afunc    ********************/
Afunc::Afunc(Function_def *p1)
{
  function_def_ = p1;

}

Afunc::Afunc(const Afunc & other)
{
  function_def_ = other.function_def_->clone();

}

Afunc &Afunc::operator=(const Afunc & other)
{
  Afunc tmp(other);
  swap(tmp);
  return *this;
}

void Afunc::swap(Afunc & other)
{
  std::swap(function_def_, other.function_def_);

}

Afunc::~Afunc()
{
  delete(function_def_);

}

void Afunc::accept(Visitor *v)
{
  v->visitAfunc(this);
}

Afunc *Afunc::clone() const
{
  return new Afunc(*this);
}



/********************   Global    ********************/
Global::Global(Dec *p1)
{
  dec_ = p1;

}

Global::Global(const Global & other)
{
  dec_ = other.dec_->clone();

}

Global &Global::operator=(const Global & other)
{
  Global tmp(other);
  swap(tmp);
  return *this;
}

void Global::swap(Global & other)
{
  std::swap(dec_, other.dec_);

}

Global::~Global()
{
  delete(dec_);

}

void Global::accept(Visitor *v)
{
  v->visitGlobal(this);
}

Global *Global::clone() const
{
  return new Global(*this);
}



/********************   OldFunc    ********************/
OldFunc::OldFunc(ListDeclaration_specifier *p1, Declarator *p2, ListDec *p3, Compound_stm *p4)
{
  listdeclaration_specifier_ = p1;
  declarator_ = p2;
  listdec_ = p3;
  compound_stm_ = p4;

}

OldFunc::OldFunc(const OldFunc & other)
{
  listdeclaration_specifier_ = other.listdeclaration_specifier_->clone();
  declarator_ = other.declarator_->clone();
  listdec_ = other.listdec_->clone();
  compound_stm_ = other.compound_stm_->clone();

}

OldFunc &OldFunc::operator=(const OldFunc & other)
{
  OldFunc tmp(other);
  swap(tmp);
  return *this;
}

void OldFunc::swap(OldFunc & other)
{
  std::swap(listdeclaration_specifier_, other.listdeclaration_specifier_);
  std::swap(declarator_, other.declarator_);
  std::swap(listdec_, other.listdec_);
  std::swap(compound_stm_, other.compound_stm_);

}

OldFunc::~OldFunc()
{
  delete(listdeclaration_specifier_);
  delete(declarator_);
  delete(listdec_);
  delete(compound_stm_);

}

void OldFunc::accept(Visitor *v)
{
  v->visitOldFunc(this);
}

OldFunc *OldFunc::clone() const
{
  return new OldFunc(*this);
}



/********************   NewFunc    ********************/
NewFunc::NewFunc(ListDeclaration_specifier *p1, Declarator *p2, Compound_stm *p3)
{
  listdeclaration_specifier_ = p1;
  declarator_ = p2;
  compound_stm_ = p3;

}

NewFunc::NewFunc(const NewFunc & other)
{
  listdeclaration_specifier_ = other.listdeclaration_specifier_->clone();
  declarator_ = other.declarator_->clone();
  compound_stm_ = other.compound_stm_->clone();

}

NewFunc &NewFunc::operator=(const NewFunc & other)
{
  NewFunc tmp(other);
  swap(tmp);
  return *this;
}

void NewFunc::swap(NewFunc & other)
{
  std::swap(listdeclaration_specifier_, other.listdeclaration_specifier_);
  std::swap(declarator_, other.declarator_);
  std::swap(compound_stm_, other.compound_stm_);

}

NewFunc::~NewFunc()
{
  delete(listdeclaration_specifier_);
  delete(declarator_);
  delete(compound_stm_);

}

void NewFunc::accept(Visitor *v)
{
  v->visitNewFunc(this);
}

NewFunc *NewFunc::clone() const
{
  return new NewFunc(*this);
}



/********************   OldFuncInt    ********************/
OldFuncInt::OldFuncInt(Declarator *p1, ListDec *p2, Compound_stm *p3)
{
  declarator_ = p1;
  listdec_ = p2;
  compound_stm_ = p3;

}

OldFuncInt::OldFuncInt(const OldFuncInt & other)
{
  declarator_ = other.declarator_->clone();
  listdec_ = other.listdec_->clone();
  compound_stm_ = other.compound_stm_->clone();

}

OldFuncInt &OldFuncInt::operator=(const OldFuncInt & other)
{
  OldFuncInt tmp(other);
  swap(tmp);
  return *this;
}

void OldFuncInt::swap(OldFuncInt & other)
{
  std::swap(declarator_, other.declarator_);
  std::swap(listdec_, other.listdec_);
  std::swap(compound_stm_, other.compound_stm_);

}

OldFuncInt::~OldFuncInt()
{
  delete(declarator_);
  delete(listdec_);
  delete(compound_stm_);

}

void OldFuncInt::accept(Visitor *v)
{
  v->visitOldFuncInt(this);
}

OldFuncInt *OldFuncInt::clone() const
{
  return new OldFuncInt(*this);
}



/********************   NewFuncInt    ********************/
NewFuncInt::NewFuncInt(Declarator *p1, Compound_stm *p2)
{
  declarator_ = p1;
  compound_stm_ = p2;

}

NewFuncInt::NewFuncInt(const NewFuncInt & other)
{
  declarator_ = other.declarator_->clone();
  compound_stm_ = other.compound_stm_->clone();

}

NewFuncInt &NewFuncInt::operator=(const NewFuncInt & other)
{
  NewFuncInt tmp(other);
  swap(tmp);
  return *this;
}

void NewFuncInt::swap(NewFuncInt & other)
{
  std::swap(declarator_, other.declarator_);
  std::swap(compound_stm_, other.compound_stm_);

}

NewFuncInt::~NewFuncInt()
{
  delete(declarator_);
  delete(compound_stm_);

}

void NewFuncInt::accept(Visitor *v)
{
  v->visitNewFuncInt(this);
}

NewFuncInt *NewFuncInt::clone() const
{
  return new NewFuncInt(*this);
}



/********************   NoDeclarator    ********************/
NoDeclarator::NoDeclarator(ListDeclaration_specifier *p1)
{
  listdeclaration_specifier_ = p1;

}

NoDeclarator::NoDeclarator(const NoDeclarator & other)
{
  listdeclaration_specifier_ = other.listdeclaration_specifier_->clone();

}

NoDeclarator &NoDeclarator::operator=(const NoDeclarator & other)
{
  NoDeclarator tmp(other);
  swap(tmp);
  return *this;
}

void NoDeclarator::swap(NoDeclarator & other)
{
  std::swap(listdeclaration_specifier_, other.listdeclaration_specifier_);

}

NoDeclarator::~NoDeclarator()
{
  delete(listdeclaration_specifier_);

}

void NoDeclarator::accept(Visitor *v)
{
  v->visitNoDeclarator(this);
}

NoDeclarator *NoDeclarator::clone() const
{
  return new NoDeclarator(*this);
}



/********************   Declarators    ********************/
Declarators::Declarators(ListDeclaration_specifier *p1, ListInit_declarator *p2)
{
  listdeclaration_specifier_ = p1;
  listinit_declarator_ = p2;

}

Declarators::Declarators(const Declarators & other)
{
  listdeclaration_specifier_ = other.listdeclaration_specifier_->clone();
  listinit_declarator_ = other.listinit_declarator_->clone();

}

Declarators &Declarators::operator=(const Declarators & other)
{
  Declarators tmp(other);
  swap(tmp);
  return *this;
}

void Declarators::swap(Declarators & other)
{
  std::swap(listdeclaration_specifier_, other.listdeclaration_specifier_);
  std::swap(listinit_declarator_, other.listinit_declarator_);

}

Declarators::~Declarators()
{
  delete(listdeclaration_specifier_);
  delete(listinit_declarator_);

}

void Declarators::accept(Visitor *v)
{
  v->visitDeclarators(this);
}

Declarators *Declarators::clone() const
{
  return new Declarators(*this);
}



/********************   Type    ********************/
Type::Type(Type_specifier *p1)
{
  type_specifier_ = p1;

}

Type::Type(const Type & other)
{
  type_specifier_ = other.type_specifier_->clone();

}

Type &Type::operator=(const Type & other)
{
  Type tmp(other);
  swap(tmp);
  return *this;
}

void Type::swap(Type & other)
{
  std::swap(type_specifier_, other.type_specifier_);

}

Type::~Type()
{
  delete(type_specifier_);

}

void Type::accept(Visitor *v)
{
  v->visitType(this);
}

Type *Type::clone() const
{
  return new Type(*this);
}



/********************   Storage    ********************/
Storage::Storage(Storage_class_specifier *p1)
{
  storage_class_specifier_ = p1;

}

Storage::Storage(const Storage & other)
{
  storage_class_specifier_ = other.storage_class_specifier_->clone();

}

Storage &Storage::operator=(const Storage & other)
{
  Storage tmp(other);
  swap(tmp);
  return *this;
}

void Storage::swap(Storage & other)
{
  std::swap(storage_class_specifier_, other.storage_class_specifier_);

}

Storage::~Storage()
{
  delete(storage_class_specifier_);

}

void Storage::accept(Visitor *v)
{
  v->visitStorage(this);
}

Storage *Storage::clone() const
{
  return new Storage(*this);
}



/********************   SpecProp    ********************/
SpecProp::SpecProp(Type_qualifier *p1)
{
  type_qualifier_ = p1;

}

SpecProp::SpecProp(const SpecProp & other)
{
  type_qualifier_ = other.type_qualifier_->clone();

}

SpecProp &SpecProp::operator=(const SpecProp & other)
{
  SpecProp tmp(other);
  swap(tmp);
  return *this;
}

void SpecProp::swap(SpecProp & other)
{
  std::swap(type_qualifier_, other.type_qualifier_);

}

SpecProp::~SpecProp()
{
  delete(type_qualifier_);

}

void SpecProp::accept(Visitor *v)
{
  v->visitSpecProp(this);
}

SpecProp *SpecProp::clone() const
{
  return new SpecProp(*this);
}



/********************   OnlyDecl    ********************/
OnlyDecl::OnlyDecl(Declarator *p1)
{
  declarator_ = p1;

}

OnlyDecl::OnlyDecl(const OnlyDecl & other)
{
  declarator_ = other.declarator_->clone();

}

OnlyDecl &OnlyDecl::operator=(const OnlyDecl & other)
{
  OnlyDecl tmp(other);
  swap(tmp);
  return *this;
}

void OnlyDecl::swap(OnlyDecl & other)
{
  std::swap(declarator_, other.declarator_);

}

OnlyDecl::~OnlyDecl()
{
  delete(declarator_);

}

void OnlyDecl::accept(Visitor *v)
{
  v->visitOnlyDecl(this);
}

OnlyDecl *OnlyDecl::clone() const
{
  return new OnlyDecl(*this);
}



/********************   InitDecl    ********************/
InitDecl::InitDecl(Declarator *p1, Initializer *p2)
{
  declarator_ = p1;
  initializer_ = p2;

}

InitDecl::InitDecl(const InitDecl & other)
{
  declarator_ = other.declarator_->clone();
  initializer_ = other.initializer_->clone();

}

InitDecl &InitDecl::operator=(const InitDecl & other)
{
  InitDecl tmp(other);
  swap(tmp);
  return *this;
}

void InitDecl::swap(InitDecl & other)
{
  std::swap(declarator_, other.declarator_);
  std::swap(initializer_, other.initializer_);

}

InitDecl::~InitDecl()
{
  delete(declarator_);
  delete(initializer_);

}

void InitDecl::accept(Visitor *v)
{
  v->visitInitDecl(this);
}

InitDecl *InitDecl::clone() const
{
  return new InitDecl(*this);
}



/********************   Tvoid    ********************/
Tvoid::Tvoid()
{

}

Tvoid::Tvoid(const Tvoid & other)
{

}

Tvoid &Tvoid::operator=(const Tvoid & other)
{
  Tvoid tmp(other);
  swap(tmp);
  return *this;
}

void Tvoid::swap(Tvoid & other)
{

}

Tvoid::~Tvoid()
{

}

void Tvoid::accept(Visitor *v)
{
  v->visitTvoid(this);
}

Tvoid *Tvoid::clone() const
{
  return new Tvoid(*this);
}



/********************   Tchar    ********************/
Tchar::Tchar()
{

}

Tchar::Tchar(const Tchar & other)
{

}

Tchar &Tchar::operator=(const Tchar & other)
{
  Tchar tmp(other);
  swap(tmp);
  return *this;
}

void Tchar::swap(Tchar & other)
{

}

Tchar::~Tchar()
{

}

void Tchar::accept(Visitor *v)
{
  v->visitTchar(this);
}

Tchar *Tchar::clone() const
{
  return new Tchar(*this);
}



/********************   Tshort    ********************/
Tshort::Tshort()
{

}

Tshort::Tshort(const Tshort & other)
{

}

Tshort &Tshort::operator=(const Tshort & other)
{
  Tshort tmp(other);
  swap(tmp);
  return *this;
}

void Tshort::swap(Tshort & other)
{

}

Tshort::~Tshort()
{

}

void Tshort::accept(Visitor *v)
{
  v->visitTshort(this);
}

Tshort *Tshort::clone() const
{
  return new Tshort(*this);
}



/********************   Tint    ********************/
Tint::Tint()
{

}

Tint::Tint(const Tint & other)
{

}

Tint &Tint::operator=(const Tint & other)
{
  Tint tmp(other);
  swap(tmp);
  return *this;
}

void Tint::swap(Tint & other)
{

}

Tint::~Tint()
{

}

void Tint::accept(Visitor *v)
{
  v->visitTint(this);
}

Tint *Tint::clone() const
{
  return new Tint(*this);
}



/********************   Tlong    ********************/
Tlong::Tlong()
{

}

Tlong::Tlong(const Tlong & other)
{

}

Tlong &Tlong::operator=(const Tlong & other)
{
  Tlong tmp(other);
  swap(tmp);
  return *this;
}

void Tlong::swap(Tlong & other)
{

}

Tlong::~Tlong()
{

}

void Tlong::accept(Visitor *v)
{
  v->visitTlong(this);
}

Tlong *Tlong::clone() const
{
  return new Tlong(*this);
}



/********************   Tfloat    ********************/
Tfloat::Tfloat()
{

}

Tfloat::Tfloat(const Tfloat & other)
{

}

Tfloat &Tfloat::operator=(const Tfloat & other)
{
  Tfloat tmp(other);
  swap(tmp);
  return *this;
}

void Tfloat::swap(Tfloat & other)
{

}

Tfloat::~Tfloat()
{

}

void Tfloat::accept(Visitor *v)
{
  v->visitTfloat(this);
}

Tfloat *Tfloat::clone() const
{
  return new Tfloat(*this);
}



/********************   Tdouble    ********************/
Tdouble::Tdouble()
{

}

Tdouble::Tdouble(const Tdouble & other)
{

}

Tdouble &Tdouble::operator=(const Tdouble & other)
{
  Tdouble tmp(other);
  swap(tmp);
  return *this;
}

void Tdouble::swap(Tdouble & other)
{

}

Tdouble::~Tdouble()
{

}

void Tdouble::accept(Visitor *v)
{
  v->visitTdouble(this);
}

Tdouble *Tdouble::clone() const
{
  return new Tdouble(*this);
}



/********************   Tsigned    ********************/
Tsigned::Tsigned()
{

}

Tsigned::Tsigned(const Tsigned & other)
{

}

Tsigned &Tsigned::operator=(const Tsigned & other)
{
  Tsigned tmp(other);
  swap(tmp);
  return *this;
}

void Tsigned::swap(Tsigned & other)
{

}

Tsigned::~Tsigned()
{

}

void Tsigned::accept(Visitor *v)
{
  v->visitTsigned(this);
}

Tsigned *Tsigned::clone() const
{
  return new Tsigned(*this);
}



/********************   Tunsigned    ********************/
Tunsigned::Tunsigned()
{

}

Tunsigned::Tunsigned(const Tunsigned & other)
{

}

Tunsigned &Tunsigned::operator=(const Tunsigned & other)
{
  Tunsigned tmp(other);
  swap(tmp);
  return *this;
}

void Tunsigned::swap(Tunsigned & other)
{

}

Tunsigned::~Tunsigned()
{

}

void Tunsigned::accept(Visitor *v)
{
  v->visitTunsigned(this);
}

Tunsigned *Tunsigned::clone() const
{
  return new Tunsigned(*this);
}



/********************   Tstruct    ********************/
Tstruct::Tstruct(Struct_or_union_spec *p1)
{
  struct_or_union_spec_ = p1;

}

Tstruct::Tstruct(const Tstruct & other)
{
  struct_or_union_spec_ = other.struct_or_union_spec_->clone();

}

Tstruct &Tstruct::operator=(const Tstruct & other)
{
  Tstruct tmp(other);
  swap(tmp);
  return *this;
}

void Tstruct::swap(Tstruct & other)
{
  std::swap(struct_or_union_spec_, other.struct_or_union_spec_);

}

Tstruct::~Tstruct()
{
  delete(struct_or_union_spec_);

}

void Tstruct::accept(Visitor *v)
{
  v->visitTstruct(this);
}

Tstruct *Tstruct::clone() const
{
  return new Tstruct(*this);
}



/********************   Tenum    ********************/
Tenum::Tenum(Enum_specifier *p1)
{
  enum_specifier_ = p1;

}

Tenum::Tenum(const Tenum & other)
{
  enum_specifier_ = other.enum_specifier_->clone();

}

Tenum &Tenum::operator=(const Tenum & other)
{
  Tenum tmp(other);
  swap(tmp);
  return *this;
}

void Tenum::swap(Tenum & other)
{
  std::swap(enum_specifier_, other.enum_specifier_);

}

Tenum::~Tenum()
{
  delete(enum_specifier_);

}

void Tenum::accept(Visitor *v)
{
  v->visitTenum(this);
}

Tenum *Tenum::clone() const
{
  return new Tenum(*this);
}



/********************   Tname    ********************/
Tname::Tname()
{

}

Tname::Tname(const Tname & other)
{

}

Tname &Tname::operator=(const Tname & other)
{
  Tname tmp(other);
  swap(tmp);
  return *this;
}

void Tname::swap(Tname & other)
{

}

Tname::~Tname()
{

}

void Tname::accept(Visitor *v)
{
  v->visitTname(this);
}

Tname *Tname::clone() const
{
  return new Tname(*this);
}



/********************   MyType    ********************/
MyType::MyType()
{

}

MyType::MyType(const MyType & other)
{

}

MyType &MyType::operator=(const MyType & other)
{
  MyType tmp(other);
  swap(tmp);
  return *this;
}

void MyType::swap(MyType & other)
{

}

MyType::~MyType()
{

}

void MyType::accept(Visitor *v)
{
  v->visitMyType(this);
}

MyType *MyType::clone() const
{
  return new MyType(*this);
}



/********************   GlobalPrograms    ********************/
GlobalPrograms::GlobalPrograms()
{

}

GlobalPrograms::GlobalPrograms(const GlobalPrograms & other)
{

}

GlobalPrograms &GlobalPrograms::operator=(const GlobalPrograms & other)
{
  GlobalPrograms tmp(other);
  swap(tmp);
  return *this;
}

void GlobalPrograms::swap(GlobalPrograms & other)
{

}

GlobalPrograms::~GlobalPrograms()
{

}

void GlobalPrograms::accept(Visitor *v)
{
  v->visitGlobalPrograms(this);
}

GlobalPrograms *GlobalPrograms::clone() const
{
  return new GlobalPrograms(*this);
}



/********************   LocalProgram    ********************/
LocalProgram::LocalProgram()
{

}

LocalProgram::LocalProgram(const LocalProgram & other)
{

}

LocalProgram &LocalProgram::operator=(const LocalProgram & other)
{
  LocalProgram tmp(other);
  swap(tmp);
  return *this;
}

void LocalProgram::swap(LocalProgram & other)
{

}

LocalProgram::~LocalProgram()
{

}

void LocalProgram::accept(Visitor *v)
{
  v->visitLocalProgram(this);
}

LocalProgram *LocalProgram::clone() const
{
  return new LocalProgram(*this);
}



/********************   LocalBlock    ********************/
LocalBlock::LocalBlock()
{

}

LocalBlock::LocalBlock(const LocalBlock & other)
{

}

LocalBlock &LocalBlock::operator=(const LocalBlock & other)
{
  LocalBlock tmp(other);
  swap(tmp);
  return *this;
}

void LocalBlock::swap(LocalBlock & other)
{

}

LocalBlock::~LocalBlock()
{

}

void LocalBlock::accept(Visitor *v)
{
  v->visitLocalBlock(this);
}

LocalBlock *LocalBlock::clone() const
{
  return new LocalBlock(*this);
}



/********************   LocalReg    ********************/
LocalReg::LocalReg()
{

}

LocalReg::LocalReg(const LocalReg & other)
{

}

LocalReg &LocalReg::operator=(const LocalReg & other)
{
  LocalReg tmp(other);
  swap(tmp);
  return *this;
}

void LocalReg::swap(LocalReg & other)
{

}

LocalReg::~LocalReg()
{

}

void LocalReg::accept(Visitor *v)
{
  v->visitLocalReg(this);
}

LocalReg *LocalReg::clone() const
{
  return new LocalReg(*this);
}



/********************   Const    ********************/
Const::Const()
{

}

Const::Const(const Const & other)
{

}

Const &Const::operator=(const Const & other)
{
  Const tmp(other);
  swap(tmp);
  return *this;
}

void Const::swap(Const & other)
{

}

Const::~Const()
{

}

void Const::accept(Visitor *v)
{
  v->visitConst(this);
}

Const *Const::clone() const
{
  return new Const(*this);
}



/********************   NoOptim    ********************/
NoOptim::NoOptim()
{

}

NoOptim::NoOptim(const NoOptim & other)
{

}

NoOptim &NoOptim::operator=(const NoOptim & other)
{
  NoOptim tmp(other);
  swap(tmp);
  return *this;
}

void NoOptim::swap(NoOptim & other)
{

}

NoOptim::~NoOptim()
{

}

void NoOptim::accept(Visitor *v)
{
  v->visitNoOptim(this);
}

NoOptim *NoOptim::clone() const
{
  return new NoOptim(*this);
}



/********************   Tag    ********************/
Tag::Tag(Struct_or_union *p1, Ident p2, ListStruct_dec *p3)
{
  struct_or_union_ = p1;
  ident_ = p2;
  liststruct_dec_ = p3;

}

Tag::Tag(const Tag & other)
{
  struct_or_union_ = other.struct_or_union_->clone();
  ident_ = other.ident_;
  liststruct_dec_ = other.liststruct_dec_->clone();

}

Tag &Tag::operator=(const Tag & other)
{
  Tag tmp(other);
  swap(tmp);
  return *this;
}

void Tag::swap(Tag & other)
{
  std::swap(struct_or_union_, other.struct_or_union_);
  std::swap(ident_, other.ident_);
  std::swap(liststruct_dec_, other.liststruct_dec_);

}

Tag::~Tag()
{
  delete(struct_or_union_);
  delete(liststruct_dec_);

}

void Tag::accept(Visitor *v)
{
  v->visitTag(this);
}

Tag *Tag::clone() const
{
  return new Tag(*this);
}



/********************   Unique    ********************/
Unique::Unique(Struct_or_union *p1, ListStruct_dec *p2)
{
  struct_or_union_ = p1;
  liststruct_dec_ = p2;

}

Unique::Unique(const Unique & other)
{
  struct_or_union_ = other.struct_or_union_->clone();
  liststruct_dec_ = other.liststruct_dec_->clone();

}

Unique &Unique::operator=(const Unique & other)
{
  Unique tmp(other);
  swap(tmp);
  return *this;
}

void Unique::swap(Unique & other)
{
  std::swap(struct_or_union_, other.struct_or_union_);
  std::swap(liststruct_dec_, other.liststruct_dec_);

}

Unique::~Unique()
{
  delete(struct_or_union_);
  delete(liststruct_dec_);

}

void Unique::accept(Visitor *v)
{
  v->visitUnique(this);
}

Unique *Unique::clone() const
{
  return new Unique(*this);
}



/********************   TagType    ********************/
TagType::TagType(Struct_or_union *p1, Ident p2)
{
  struct_or_union_ = p1;
  ident_ = p2;

}

TagType::TagType(const TagType & other)
{
  struct_or_union_ = other.struct_or_union_->clone();
  ident_ = other.ident_;

}

TagType &TagType::operator=(const TagType & other)
{
  TagType tmp(other);
  swap(tmp);
  return *this;
}

void TagType::swap(TagType & other)
{
  std::swap(struct_or_union_, other.struct_or_union_);
  std::swap(ident_, other.ident_);

}

TagType::~TagType()
{
  delete(struct_or_union_);

}

void TagType::accept(Visitor *v)
{
  v->visitTagType(this);
}

TagType *TagType::clone() const
{
  return new TagType(*this);
}



/********************   Struct    ********************/
Struct::Struct()
{

}

Struct::Struct(const Struct & other)
{

}

Struct &Struct::operator=(const Struct & other)
{
  Struct tmp(other);
  swap(tmp);
  return *this;
}

void Struct::swap(Struct & other)
{

}

Struct::~Struct()
{

}

void Struct::accept(Visitor *v)
{
  v->visitStruct(this);
}

Struct *Struct::clone() const
{
  return new Struct(*this);
}



/********************   Union    ********************/
Union::Union()
{

}

Union::Union(const Union & other)
{

}

Union &Union::operator=(const Union & other)
{
  Union tmp(other);
  swap(tmp);
  return *this;
}

void Union::swap(Union & other)
{

}

Union::~Union()
{

}

void Union::accept(Visitor *v)
{
  v->visitUnion(this);
}

Union *Union::clone() const
{
  return new Union(*this);
}



/********************   Structen    ********************/
Structen::Structen(ListSpec_qual *p1, ListStruct_declarator *p2)
{
  listspec_qual_ = p1;
  liststruct_declarator_ = p2;

}

Structen::Structen(const Structen & other)
{
  listspec_qual_ = other.listspec_qual_->clone();
  liststruct_declarator_ = other.liststruct_declarator_->clone();

}

Structen &Structen::operator=(const Structen & other)
{
  Structen tmp(other);
  swap(tmp);
  return *this;
}

void Structen::swap(Structen & other)
{
  std::swap(listspec_qual_, other.listspec_qual_);
  std::swap(liststruct_declarator_, other.liststruct_declarator_);

}

Structen::~Structen()
{
  delete(listspec_qual_);
  delete(liststruct_declarator_);

}

void Structen::accept(Visitor *v)
{
  v->visitStructen(this);
}

Structen *Structen::clone() const
{
  return new Structen(*this);
}



/********************   TypeSpec    ********************/
TypeSpec::TypeSpec(Type_specifier *p1)
{
  type_specifier_ = p1;

}

TypeSpec::TypeSpec(const TypeSpec & other)
{
  type_specifier_ = other.type_specifier_->clone();

}

TypeSpec &TypeSpec::operator=(const TypeSpec & other)
{
  TypeSpec tmp(other);
  swap(tmp);
  return *this;
}

void TypeSpec::swap(TypeSpec & other)
{
  std::swap(type_specifier_, other.type_specifier_);

}

TypeSpec::~TypeSpec()
{
  delete(type_specifier_);

}

void TypeSpec::accept(Visitor *v)
{
  v->visitTypeSpec(this);
}

TypeSpec *TypeSpec::clone() const
{
  return new TypeSpec(*this);
}



/********************   QualSpec    ********************/
QualSpec::QualSpec(Type_qualifier *p1)
{
  type_qualifier_ = p1;

}

QualSpec::QualSpec(const QualSpec & other)
{
  type_qualifier_ = other.type_qualifier_->clone();

}

QualSpec &QualSpec::operator=(const QualSpec & other)
{
  QualSpec tmp(other);
  swap(tmp);
  return *this;
}

void QualSpec::swap(QualSpec & other)
{
  std::swap(type_qualifier_, other.type_qualifier_);

}

QualSpec::~QualSpec()
{
  delete(type_qualifier_);

}

void QualSpec::accept(Visitor *v)
{
  v->visitQualSpec(this);
}

QualSpec *QualSpec::clone() const
{
  return new QualSpec(*this);
}



/********************   Decl    ********************/
Decl::Decl(Declarator *p1)
{
  declarator_ = p1;

}

Decl::Decl(const Decl & other)
{
  declarator_ = other.declarator_->clone();

}

Decl &Decl::operator=(const Decl & other)
{
  Decl tmp(other);
  swap(tmp);
  return *this;
}

void Decl::swap(Decl & other)
{
  std::swap(declarator_, other.declarator_);

}

Decl::~Decl()
{
  delete(declarator_);

}

void Decl::accept(Visitor *v)
{
  v->visitDecl(this);
}

Decl *Decl::clone() const
{
  return new Decl(*this);
}



/********************   Field    ********************/
Field::Field(Constant_expression *p1)
{
  constant_expression_ = p1;

}

Field::Field(const Field & other)
{
  constant_expression_ = other.constant_expression_->clone();

}

Field &Field::operator=(const Field & other)
{
  Field tmp(other);
  swap(tmp);
  return *this;
}

void Field::swap(Field & other)
{
  std::swap(constant_expression_, other.constant_expression_);

}

Field::~Field()
{
  delete(constant_expression_);

}

void Field::accept(Visitor *v)
{
  v->visitField(this);
}

Field *Field::clone() const
{
  return new Field(*this);
}



/********************   DecField    ********************/
DecField::DecField(Declarator *p1, Constant_expression *p2)
{
  declarator_ = p1;
  constant_expression_ = p2;

}

DecField::DecField(const DecField & other)
{
  declarator_ = other.declarator_->clone();
  constant_expression_ = other.constant_expression_->clone();

}

DecField &DecField::operator=(const DecField & other)
{
  DecField tmp(other);
  swap(tmp);
  return *this;
}

void DecField::swap(DecField & other)
{
  std::swap(declarator_, other.declarator_);
  std::swap(constant_expression_, other.constant_expression_);

}

DecField::~DecField()
{
  delete(declarator_);
  delete(constant_expression_);

}

void DecField::accept(Visitor *v)
{
  v->visitDecField(this);
}

DecField *DecField::clone() const
{
  return new DecField(*this);
}



/********************   EnumDec    ********************/
EnumDec::EnumDec(ListEnumerator *p1)
{
  listenumerator_ = p1;

}

EnumDec::EnumDec(const EnumDec & other)
{
  listenumerator_ = other.listenumerator_->clone();

}

EnumDec &EnumDec::operator=(const EnumDec & other)
{
  EnumDec tmp(other);
  swap(tmp);
  return *this;
}

void EnumDec::swap(EnumDec & other)
{
  std::swap(listenumerator_, other.listenumerator_);

}

EnumDec::~EnumDec()
{
  delete(listenumerator_);

}

void EnumDec::accept(Visitor *v)
{
  v->visitEnumDec(this);
}

EnumDec *EnumDec::clone() const
{
  return new EnumDec(*this);
}



/********************   EnumName    ********************/
EnumName::EnumName(Ident p1, ListEnumerator *p2)
{
  ident_ = p1;
  listenumerator_ = p2;

}

EnumName::EnumName(const EnumName & other)
{
  ident_ = other.ident_;
  listenumerator_ = other.listenumerator_->clone();

}

EnumName &EnumName::operator=(const EnumName & other)
{
  EnumName tmp(other);
  swap(tmp);
  return *this;
}

void EnumName::swap(EnumName & other)
{
  std::swap(ident_, other.ident_);
  std::swap(listenumerator_, other.listenumerator_);

}

EnumName::~EnumName()
{
  delete(listenumerator_);

}

void EnumName::accept(Visitor *v)
{
  v->visitEnumName(this);
}

EnumName *EnumName::clone() const
{
  return new EnumName(*this);
}



/********************   EnumVar    ********************/
EnumVar::EnumVar(Ident p1)
{
  ident_ = p1;

}

EnumVar::EnumVar(const EnumVar & other)
{
  ident_ = other.ident_;

}

EnumVar &EnumVar::operator=(const EnumVar & other)
{
  EnumVar tmp(other);
  swap(tmp);
  return *this;
}

void EnumVar::swap(EnumVar & other)
{
  std::swap(ident_, other.ident_);

}

EnumVar::~EnumVar()
{

}

void EnumVar::accept(Visitor *v)
{
  v->visitEnumVar(this);
}

EnumVar *EnumVar::clone() const
{
  return new EnumVar(*this);
}



/********************   Plain    ********************/
Plain::Plain(Ident p1)
{
  ident_ = p1;

}

Plain::Plain(const Plain & other)
{
  ident_ = other.ident_;

}

Plain &Plain::operator=(const Plain & other)
{
  Plain tmp(other);
  swap(tmp);
  return *this;
}

void Plain::swap(Plain & other)
{
  std::swap(ident_, other.ident_);

}

Plain::~Plain()
{

}

void Plain::accept(Visitor *v)
{
  v->visitPlain(this);
}

Plain *Plain::clone() const
{
  return new Plain(*this);
}



/********************   EnumInit    ********************/
EnumInit::EnumInit(Ident p1, Constant_expression *p2)
{
  ident_ = p1;
  constant_expression_ = p2;

}

EnumInit::EnumInit(const EnumInit & other)
{
  ident_ = other.ident_;
  constant_expression_ = other.constant_expression_->clone();

}

EnumInit &EnumInit::operator=(const EnumInit & other)
{
  EnumInit tmp(other);
  swap(tmp);
  return *this;
}

void EnumInit::swap(EnumInit & other)
{
  std::swap(ident_, other.ident_);
  std::swap(constant_expression_, other.constant_expression_);

}

EnumInit::~EnumInit()
{
  delete(constant_expression_);

}

void EnumInit::accept(Visitor *v)
{
  v->visitEnumInit(this);
}

EnumInit *EnumInit::clone() const
{
  return new EnumInit(*this);
}



/********************   BeginPointer    ********************/
BeginPointer::BeginPointer(Pointer *p1, Direct_declarator *p2)
{
  pointer_ = p1;
  direct_declarator_ = p2;

}

BeginPointer::BeginPointer(const BeginPointer & other)
{
  pointer_ = other.pointer_->clone();
  direct_declarator_ = other.direct_declarator_->clone();

}

BeginPointer &BeginPointer::operator=(const BeginPointer & other)
{
  BeginPointer tmp(other);
  swap(tmp);
  return *this;
}

void BeginPointer::swap(BeginPointer & other)
{
  std::swap(pointer_, other.pointer_);
  std::swap(direct_declarator_, other.direct_declarator_);

}

BeginPointer::~BeginPointer()
{
  delete(pointer_);
  delete(direct_declarator_);

}

void BeginPointer::accept(Visitor *v)
{
  v->visitBeginPointer(this);
}

BeginPointer *BeginPointer::clone() const
{
  return new BeginPointer(*this);
}



/********************   NoPointer    ********************/
NoPointer::NoPointer(Direct_declarator *p1)
{
  direct_declarator_ = p1;

}

NoPointer::NoPointer(const NoPointer & other)
{
  direct_declarator_ = other.direct_declarator_->clone();

}

NoPointer &NoPointer::operator=(const NoPointer & other)
{
  NoPointer tmp(other);
  swap(tmp);
  return *this;
}

void NoPointer::swap(NoPointer & other)
{
  std::swap(direct_declarator_, other.direct_declarator_);

}

NoPointer::~NoPointer()
{
  delete(direct_declarator_);

}

void NoPointer::accept(Visitor *v)
{
  v->visitNoPointer(this);
}

NoPointer *NoPointer::clone() const
{
  return new NoPointer(*this);
}



/********************   Name    ********************/
Name::Name(Ident p1)
{
  ident_ = p1;

}

Name::Name(const Name & other)
{
  ident_ = other.ident_;

}

Name &Name::operator=(const Name & other)
{
  Name tmp(other);
  swap(tmp);
  return *this;
}

void Name::swap(Name & other)
{
  std::swap(ident_, other.ident_);

}

Name::~Name()
{

}

void Name::accept(Visitor *v)
{
  v->visitName(this);
}

Name *Name::clone() const
{
  return new Name(*this);
}



/********************   ParenDecl    ********************/
ParenDecl::ParenDecl(Declarator *p1)
{
  declarator_ = p1;

}

ParenDecl::ParenDecl(const ParenDecl & other)
{
  declarator_ = other.declarator_->clone();

}

ParenDecl &ParenDecl::operator=(const ParenDecl & other)
{
  ParenDecl tmp(other);
  swap(tmp);
  return *this;
}

void ParenDecl::swap(ParenDecl & other)
{
  std::swap(declarator_, other.declarator_);

}

ParenDecl::~ParenDecl()
{
  delete(declarator_);

}

void ParenDecl::accept(Visitor *v)
{
  v->visitParenDecl(this);
}

ParenDecl *ParenDecl::clone() const
{
  return new ParenDecl(*this);
}



/********************   InnitArray    ********************/
InnitArray::InnitArray(Direct_declarator *p1, Constant_expression *p2)
{
  direct_declarator_ = p1;
  constant_expression_ = p2;

}

InnitArray::InnitArray(const InnitArray & other)
{
  direct_declarator_ = other.direct_declarator_->clone();
  constant_expression_ = other.constant_expression_->clone();

}

InnitArray &InnitArray::operator=(const InnitArray & other)
{
  InnitArray tmp(other);
  swap(tmp);
  return *this;
}

void InnitArray::swap(InnitArray & other)
{
  std::swap(direct_declarator_, other.direct_declarator_);
  std::swap(constant_expression_, other.constant_expression_);

}

InnitArray::~InnitArray()
{
  delete(direct_declarator_);
  delete(constant_expression_);

}

void InnitArray::accept(Visitor *v)
{
  v->visitInnitArray(this);
}

InnitArray *InnitArray::clone() const
{
  return new InnitArray(*this);
}



/********************   Incomplete    ********************/
Incomplete::Incomplete(Direct_declarator *p1)
{
  direct_declarator_ = p1;

}

Incomplete::Incomplete(const Incomplete & other)
{
  direct_declarator_ = other.direct_declarator_->clone();

}

Incomplete &Incomplete::operator=(const Incomplete & other)
{
  Incomplete tmp(other);
  swap(tmp);
  return *this;
}

void Incomplete::swap(Incomplete & other)
{
  std::swap(direct_declarator_, other.direct_declarator_);

}

Incomplete::~Incomplete()
{
  delete(direct_declarator_);

}

void Incomplete::accept(Visitor *v)
{
  v->visitIncomplete(this);
}

Incomplete *Incomplete::clone() const
{
  return new Incomplete(*this);
}



/********************   NewFuncDec    ********************/
NewFuncDec::NewFuncDec(Direct_declarator *p1, Parameter_type *p2)
{
  direct_declarator_ = p1;
  parameter_type_ = p2;

}

NewFuncDec::NewFuncDec(const NewFuncDec & other)
{
  direct_declarator_ = other.direct_declarator_->clone();
  parameter_type_ = other.parameter_type_->clone();

}

NewFuncDec &NewFuncDec::operator=(const NewFuncDec & other)
{
  NewFuncDec tmp(other);
  swap(tmp);
  return *this;
}

void NewFuncDec::swap(NewFuncDec & other)
{
  std::swap(direct_declarator_, other.direct_declarator_);
  std::swap(parameter_type_, other.parameter_type_);

}

NewFuncDec::~NewFuncDec()
{
  delete(direct_declarator_);
  delete(parameter_type_);

}

void NewFuncDec::accept(Visitor *v)
{
  v->visitNewFuncDec(this);
}

NewFuncDec *NewFuncDec::clone() const
{
  return new NewFuncDec(*this);
}



/********************   OldFuncDef    ********************/
OldFuncDef::OldFuncDef(Direct_declarator *p1, ListIdent *p2)
{
  direct_declarator_ = p1;
  listident_ = p2;

}

OldFuncDef::OldFuncDef(const OldFuncDef & other)
{
  direct_declarator_ = other.direct_declarator_->clone();
  listident_ = other.listident_->clone();

}

OldFuncDef &OldFuncDef::operator=(const OldFuncDef & other)
{
  OldFuncDef tmp(other);
  swap(tmp);
  return *this;
}

void OldFuncDef::swap(OldFuncDef & other)
{
  std::swap(direct_declarator_, other.direct_declarator_);
  std::swap(listident_, other.listident_);

}

OldFuncDef::~OldFuncDef()
{
  delete(direct_declarator_);
  delete(listident_);

}

void OldFuncDef::accept(Visitor *v)
{
  v->visitOldFuncDef(this);
}

OldFuncDef *OldFuncDef::clone() const
{
  return new OldFuncDef(*this);
}



/********************   OldFuncDec    ********************/
OldFuncDec::OldFuncDec(Direct_declarator *p1)
{
  direct_declarator_ = p1;

}

OldFuncDec::OldFuncDec(const OldFuncDec & other)
{
  direct_declarator_ = other.direct_declarator_->clone();

}

OldFuncDec &OldFuncDec::operator=(const OldFuncDec & other)
{
  OldFuncDec tmp(other);
  swap(tmp);
  return *this;
}

void OldFuncDec::swap(OldFuncDec & other)
{
  std::swap(direct_declarator_, other.direct_declarator_);

}

OldFuncDec::~OldFuncDec()
{
  delete(direct_declarator_);

}

void OldFuncDec::accept(Visitor *v)
{
  v->visitOldFuncDec(this);
}

OldFuncDec *OldFuncDec::clone() const
{
  return new OldFuncDec(*this);
}



/********************   Point    ********************/
Point::Point()
{

}

Point::Point(const Point & other)
{

}

Point &Point::operator=(const Point & other)
{
  Point tmp(other);
  swap(tmp);
  return *this;
}

void Point::swap(Point & other)
{

}

Point::~Point()
{

}

void Point::accept(Visitor *v)
{
  v->visitPoint(this);
}

Point *Point::clone() const
{
  return new Point(*this);
}



/********************   PointQual    ********************/
PointQual::PointQual(ListType_qualifier *p1)
{
  listtype_qualifier_ = p1;

}

PointQual::PointQual(const PointQual & other)
{
  listtype_qualifier_ = other.listtype_qualifier_->clone();

}

PointQual &PointQual::operator=(const PointQual & other)
{
  PointQual tmp(other);
  swap(tmp);
  return *this;
}

void PointQual::swap(PointQual & other)
{
  std::swap(listtype_qualifier_, other.listtype_qualifier_);

}

PointQual::~PointQual()
{
  delete(listtype_qualifier_);

}

void PointQual::accept(Visitor *v)
{
  v->visitPointQual(this);
}

PointQual *PointQual::clone() const
{
  return new PointQual(*this);
}



/********************   PointPoint    ********************/
PointPoint::PointPoint(Pointer *p1)
{
  pointer_ = p1;

}

PointPoint::PointPoint(const PointPoint & other)
{
  pointer_ = other.pointer_->clone();

}

PointPoint &PointPoint::operator=(const PointPoint & other)
{
  PointPoint tmp(other);
  swap(tmp);
  return *this;
}

void PointPoint::swap(PointPoint & other)
{
  std::swap(pointer_, other.pointer_);

}

PointPoint::~PointPoint()
{
  delete(pointer_);

}

void PointPoint::accept(Visitor *v)
{
  v->visitPointPoint(this);
}

PointPoint *PointPoint::clone() const
{
  return new PointPoint(*this);
}



/********************   PointQualPoint    ********************/
PointQualPoint::PointQualPoint(ListType_qualifier *p1, Pointer *p2)
{
  listtype_qualifier_ = p1;
  pointer_ = p2;

}

PointQualPoint::PointQualPoint(const PointQualPoint & other)
{
  listtype_qualifier_ = other.listtype_qualifier_->clone();
  pointer_ = other.pointer_->clone();

}

PointQualPoint &PointQualPoint::operator=(const PointQualPoint & other)
{
  PointQualPoint tmp(other);
  swap(tmp);
  return *this;
}

void PointQualPoint::swap(PointQualPoint & other)
{
  std::swap(listtype_qualifier_, other.listtype_qualifier_);
  std::swap(pointer_, other.pointer_);

}

PointQualPoint::~PointQualPoint()
{
  delete(listtype_qualifier_);
  delete(pointer_);

}

void PointQualPoint::accept(Visitor *v)
{
  v->visitPointQualPoint(this);
}

PointQualPoint *PointQualPoint::clone() const
{
  return new PointQualPoint(*this);
}



/********************   AllSpec    ********************/
AllSpec::AllSpec(Parameter_declarations *p1)
{
  parameter_declarations_ = p1;

}

AllSpec::AllSpec(const AllSpec & other)
{
  parameter_declarations_ = other.parameter_declarations_->clone();

}

AllSpec &AllSpec::operator=(const AllSpec & other)
{
  AllSpec tmp(other);
  swap(tmp);
  return *this;
}

void AllSpec::swap(AllSpec & other)
{
  std::swap(parameter_declarations_, other.parameter_declarations_);

}

AllSpec::~AllSpec()
{
  delete(parameter_declarations_);

}

void AllSpec::accept(Visitor *v)
{
  v->visitAllSpec(this);
}

AllSpec *AllSpec::clone() const
{
  return new AllSpec(*this);
}



/********************   More    ********************/
More::More(Parameter_declarations *p1)
{
  parameter_declarations_ = p1;

}

More::More(const More & other)
{
  parameter_declarations_ = other.parameter_declarations_->clone();

}

More &More::operator=(const More & other)
{
  More tmp(other);
  swap(tmp);
  return *this;
}

void More::swap(More & other)
{
  std::swap(parameter_declarations_, other.parameter_declarations_);

}

More::~More()
{
  delete(parameter_declarations_);

}

void More::accept(Visitor *v)
{
  v->visitMore(this);
}

More *More::clone() const
{
  return new More(*this);
}



/********************   ParamDec    ********************/
ParamDec::ParamDec(Parameter_declaration *p1)
{
  parameter_declaration_ = p1;

}

ParamDec::ParamDec(const ParamDec & other)
{
  parameter_declaration_ = other.parameter_declaration_->clone();

}

ParamDec &ParamDec::operator=(const ParamDec & other)
{
  ParamDec tmp(other);
  swap(tmp);
  return *this;
}

void ParamDec::swap(ParamDec & other)
{
  std::swap(parameter_declaration_, other.parameter_declaration_);

}

ParamDec::~ParamDec()
{
  delete(parameter_declaration_);

}

void ParamDec::accept(Visitor *v)
{
  v->visitParamDec(this);
}

ParamDec *ParamDec::clone() const
{
  return new ParamDec(*this);
}



/********************   MoreParamDec    ********************/
MoreParamDec::MoreParamDec(Parameter_declarations *p1, Parameter_declaration *p2)
{
  parameter_declarations_ = p1;
  parameter_declaration_ = p2;

}

MoreParamDec::MoreParamDec(const MoreParamDec & other)
{
  parameter_declarations_ = other.parameter_declarations_->clone();
  parameter_declaration_ = other.parameter_declaration_->clone();

}

MoreParamDec &MoreParamDec::operator=(const MoreParamDec & other)
{
  MoreParamDec tmp(other);
  swap(tmp);
  return *this;
}

void MoreParamDec::swap(MoreParamDec & other)
{
  std::swap(parameter_declarations_, other.parameter_declarations_);
  std::swap(parameter_declaration_, other.parameter_declaration_);

}

MoreParamDec::~MoreParamDec()
{
  delete(parameter_declarations_);
  delete(parameter_declaration_);

}

void MoreParamDec::accept(Visitor *v)
{
  v->visitMoreParamDec(this);
}

MoreParamDec *MoreParamDec::clone() const
{
  return new MoreParamDec(*this);
}



/********************   OnlyType    ********************/
OnlyType::OnlyType(ListDeclaration_specifier *p1)
{
  listdeclaration_specifier_ = p1;

}

OnlyType::OnlyType(const OnlyType & other)
{
  listdeclaration_specifier_ = other.listdeclaration_specifier_->clone();

}

OnlyType &OnlyType::operator=(const OnlyType & other)
{
  OnlyType tmp(other);
  swap(tmp);
  return *this;
}

void OnlyType::swap(OnlyType & other)
{
  std::swap(listdeclaration_specifier_, other.listdeclaration_specifier_);

}

OnlyType::~OnlyType()
{
  delete(listdeclaration_specifier_);

}

void OnlyType::accept(Visitor *v)
{
  v->visitOnlyType(this);
}

OnlyType *OnlyType::clone() const
{
  return new OnlyType(*this);
}



/********************   TypeAndParam    ********************/
TypeAndParam::TypeAndParam(ListDeclaration_specifier *p1, Declarator *p2)
{
  listdeclaration_specifier_ = p1;
  declarator_ = p2;

}

TypeAndParam::TypeAndParam(const TypeAndParam & other)
{
  listdeclaration_specifier_ = other.listdeclaration_specifier_->clone();
  declarator_ = other.declarator_->clone();

}

TypeAndParam &TypeAndParam::operator=(const TypeAndParam & other)
{
  TypeAndParam tmp(other);
  swap(tmp);
  return *this;
}

void TypeAndParam::swap(TypeAndParam & other)
{
  std::swap(listdeclaration_specifier_, other.listdeclaration_specifier_);
  std::swap(declarator_, other.declarator_);

}

TypeAndParam::~TypeAndParam()
{
  delete(listdeclaration_specifier_);
  delete(declarator_);

}

void TypeAndParam::accept(Visitor *v)
{
  v->visitTypeAndParam(this);
}

TypeAndParam *TypeAndParam::clone() const
{
  return new TypeAndParam(*this);
}



/********************   Abstract    ********************/
Abstract::Abstract(ListDeclaration_specifier *p1, Abstract_declarator *p2)
{
  listdeclaration_specifier_ = p1;
  abstract_declarator_ = p2;

}

Abstract::Abstract(const Abstract & other)
{
  listdeclaration_specifier_ = other.listdeclaration_specifier_->clone();
  abstract_declarator_ = other.abstract_declarator_->clone();

}

Abstract &Abstract::operator=(const Abstract & other)
{
  Abstract tmp(other);
  swap(tmp);
  return *this;
}

void Abstract::swap(Abstract & other)
{
  std::swap(listdeclaration_specifier_, other.listdeclaration_specifier_);
  std::swap(abstract_declarator_, other.abstract_declarator_);

}

Abstract::~Abstract()
{
  delete(listdeclaration_specifier_);
  delete(abstract_declarator_);

}

void Abstract::accept(Visitor *v)
{
  v->visitAbstract(this);
}

Abstract *Abstract::clone() const
{
  return new Abstract(*this);
}



/********************   InitExpr    ********************/
InitExpr::InitExpr(Exp *p1)
{
  exp_ = p1;

}

InitExpr::InitExpr(const InitExpr & other)
{
  exp_ = other.exp_->clone();

}

InitExpr &InitExpr::operator=(const InitExpr & other)
{
  InitExpr tmp(other);
  swap(tmp);
  return *this;
}

void InitExpr::swap(InitExpr & other)
{
  std::swap(exp_, other.exp_);

}

InitExpr::~InitExpr()
{
  delete(exp_);

}

void InitExpr::accept(Visitor *v)
{
  v->visitInitExpr(this);
}

InitExpr *InitExpr::clone() const
{
  return new InitExpr(*this);
}



/********************   InitListOne    ********************/
InitListOne::InitListOne(Initializers *p1)
{
  initializers_ = p1;

}

InitListOne::InitListOne(const InitListOne & other)
{
  initializers_ = other.initializers_->clone();

}

InitListOne &InitListOne::operator=(const InitListOne & other)
{
  InitListOne tmp(other);
  swap(tmp);
  return *this;
}

void InitListOne::swap(InitListOne & other)
{
  std::swap(initializers_, other.initializers_);

}

InitListOne::~InitListOne()
{
  delete(initializers_);

}

void InitListOne::accept(Visitor *v)
{
  v->visitInitListOne(this);
}

InitListOne *InitListOne::clone() const
{
  return new InitListOne(*this);
}



/********************   InitListTwo    ********************/
InitListTwo::InitListTwo(Initializers *p1)
{
  initializers_ = p1;

}

InitListTwo::InitListTwo(const InitListTwo & other)
{
  initializers_ = other.initializers_->clone();

}

InitListTwo &InitListTwo::operator=(const InitListTwo & other)
{
  InitListTwo tmp(other);
  swap(tmp);
  return *this;
}

void InitListTwo::swap(InitListTwo & other)
{
  std::swap(initializers_, other.initializers_);

}

InitListTwo::~InitListTwo()
{
  delete(initializers_);

}

void InitListTwo::accept(Visitor *v)
{
  v->visitInitListTwo(this);
}

InitListTwo *InitListTwo::clone() const
{
  return new InitListTwo(*this);
}



/********************   AnInit    ********************/
AnInit::AnInit(Initializer *p1)
{
  initializer_ = p1;

}

AnInit::AnInit(const AnInit & other)
{
  initializer_ = other.initializer_->clone();

}

AnInit &AnInit::operator=(const AnInit & other)
{
  AnInit tmp(other);
  swap(tmp);
  return *this;
}

void AnInit::swap(AnInit & other)
{
  std::swap(initializer_, other.initializer_);

}

AnInit::~AnInit()
{
  delete(initializer_);

}

void AnInit::accept(Visitor *v)
{
  v->visitAnInit(this);
}

AnInit *AnInit::clone() const
{
  return new AnInit(*this);
}



/********************   MoreInit    ********************/
MoreInit::MoreInit(Initializers *p1, Initializer *p2)
{
  initializers_ = p1;
  initializer_ = p2;

}

MoreInit::MoreInit(const MoreInit & other)
{
  initializers_ = other.initializers_->clone();
  initializer_ = other.initializer_->clone();

}

MoreInit &MoreInit::operator=(const MoreInit & other)
{
  MoreInit tmp(other);
  swap(tmp);
  return *this;
}

void MoreInit::swap(MoreInit & other)
{
  std::swap(initializers_, other.initializers_);
  std::swap(initializer_, other.initializer_);

}

MoreInit::~MoreInit()
{
  delete(initializers_);
  delete(initializer_);

}

void MoreInit::accept(Visitor *v)
{
  v->visitMoreInit(this);
}

MoreInit *MoreInit::clone() const
{
  return new MoreInit(*this);
}



/********************   PlainType    ********************/
PlainType::PlainType(ListSpec_qual *p1)
{
  listspec_qual_ = p1;

}

PlainType::PlainType(const PlainType & other)
{
  listspec_qual_ = other.listspec_qual_->clone();

}

PlainType &PlainType::operator=(const PlainType & other)
{
  PlainType tmp(other);
  swap(tmp);
  return *this;
}

void PlainType::swap(PlainType & other)
{
  std::swap(listspec_qual_, other.listspec_qual_);

}

PlainType::~PlainType()
{
  delete(listspec_qual_);

}

void PlainType::accept(Visitor *v)
{
  v->visitPlainType(this);
}

PlainType *PlainType::clone() const
{
  return new PlainType(*this);
}



/********************   ExtendedType    ********************/
ExtendedType::ExtendedType(ListSpec_qual *p1, Abstract_declarator *p2)
{
  listspec_qual_ = p1;
  abstract_declarator_ = p2;

}

ExtendedType::ExtendedType(const ExtendedType & other)
{
  listspec_qual_ = other.listspec_qual_->clone();
  abstract_declarator_ = other.abstract_declarator_->clone();

}

ExtendedType &ExtendedType::operator=(const ExtendedType & other)
{
  ExtendedType tmp(other);
  swap(tmp);
  return *this;
}

void ExtendedType::swap(ExtendedType & other)
{
  std::swap(listspec_qual_, other.listspec_qual_);
  std::swap(abstract_declarator_, other.abstract_declarator_);

}

ExtendedType::~ExtendedType()
{
  delete(listspec_qual_);
  delete(abstract_declarator_);

}

void ExtendedType::accept(Visitor *v)
{
  v->visitExtendedType(this);
}

ExtendedType *ExtendedType::clone() const
{
  return new ExtendedType(*this);
}



/********************   PointerStart    ********************/
PointerStart::PointerStart(Pointer *p1)
{
  pointer_ = p1;

}

PointerStart::PointerStart(const PointerStart & other)
{
  pointer_ = other.pointer_->clone();

}

PointerStart &PointerStart::operator=(const PointerStart & other)
{
  PointerStart tmp(other);
  swap(tmp);
  return *this;
}

void PointerStart::swap(PointerStart & other)
{
  std::swap(pointer_, other.pointer_);

}

PointerStart::~PointerStart()
{
  delete(pointer_);

}

void PointerStart::accept(Visitor *v)
{
  v->visitPointerStart(this);
}

PointerStart *PointerStart::clone() const
{
  return new PointerStart(*this);
}



/********************   Advanced    ********************/
Advanced::Advanced(Dir_abs_dec *p1)
{
  dir_abs_dec_ = p1;

}

Advanced::Advanced(const Advanced & other)
{
  dir_abs_dec_ = other.dir_abs_dec_->clone();

}

Advanced &Advanced::operator=(const Advanced & other)
{
  Advanced tmp(other);
  swap(tmp);
  return *this;
}

void Advanced::swap(Advanced & other)
{
  std::swap(dir_abs_dec_, other.dir_abs_dec_);

}

Advanced::~Advanced()
{
  delete(dir_abs_dec_);

}

void Advanced::accept(Visitor *v)
{
  v->visitAdvanced(this);
}

Advanced *Advanced::clone() const
{
  return new Advanced(*this);
}



/********************   PointAdvanced    ********************/
PointAdvanced::PointAdvanced(Pointer *p1, Dir_abs_dec *p2)
{
  pointer_ = p1;
  dir_abs_dec_ = p2;

}

PointAdvanced::PointAdvanced(const PointAdvanced & other)
{
  pointer_ = other.pointer_->clone();
  dir_abs_dec_ = other.dir_abs_dec_->clone();

}

PointAdvanced &PointAdvanced::operator=(const PointAdvanced & other)
{
  PointAdvanced tmp(other);
  swap(tmp);
  return *this;
}

void PointAdvanced::swap(PointAdvanced & other)
{
  std::swap(pointer_, other.pointer_);
  std::swap(dir_abs_dec_, other.dir_abs_dec_);

}

PointAdvanced::~PointAdvanced()
{
  delete(pointer_);
  delete(dir_abs_dec_);

}

void PointAdvanced::accept(Visitor *v)
{
  v->visitPointAdvanced(this);
}

PointAdvanced *PointAdvanced::clone() const
{
  return new PointAdvanced(*this);
}



/********************   WithinParentes    ********************/
WithinParentes::WithinParentes(Abstract_declarator *p1)
{
  abstract_declarator_ = p1;

}

WithinParentes::WithinParentes(const WithinParentes & other)
{
  abstract_declarator_ = other.abstract_declarator_->clone();

}

WithinParentes &WithinParentes::operator=(const WithinParentes & other)
{
  WithinParentes tmp(other);
  swap(tmp);
  return *this;
}

void WithinParentes::swap(WithinParentes & other)
{
  std::swap(abstract_declarator_, other.abstract_declarator_);

}

WithinParentes::~WithinParentes()
{
  delete(abstract_declarator_);

}

void WithinParentes::accept(Visitor *v)
{
  v->visitWithinParentes(this);
}

WithinParentes *WithinParentes::clone() const
{
  return new WithinParentes(*this);
}



/********************   Array    ********************/
Array::Array()
{

}

Array::Array(const Array & other)
{

}

Array &Array::operator=(const Array & other)
{
  Array tmp(other);
  swap(tmp);
  return *this;
}

void Array::swap(Array & other)
{

}

Array::~Array()
{

}

void Array::accept(Visitor *v)
{
  v->visitArray(this);
}

Array *Array::clone() const
{
  return new Array(*this);
}



/********************   InitiatedArray    ********************/
InitiatedArray::InitiatedArray(Constant_expression *p1)
{
  constant_expression_ = p1;

}

InitiatedArray::InitiatedArray(const InitiatedArray & other)
{
  constant_expression_ = other.constant_expression_->clone();

}

InitiatedArray &InitiatedArray::operator=(const InitiatedArray & other)
{
  InitiatedArray tmp(other);
  swap(tmp);
  return *this;
}

void InitiatedArray::swap(InitiatedArray & other)
{
  std::swap(constant_expression_, other.constant_expression_);

}

InitiatedArray::~InitiatedArray()
{
  delete(constant_expression_);

}

void InitiatedArray::accept(Visitor *v)
{
  v->visitInitiatedArray(this);
}

InitiatedArray *InitiatedArray::clone() const
{
  return new InitiatedArray(*this);
}



/********************   UnInitiated    ********************/
UnInitiated::UnInitiated(Dir_abs_dec *p1)
{
  dir_abs_dec_ = p1;

}

UnInitiated::UnInitiated(const UnInitiated & other)
{
  dir_abs_dec_ = other.dir_abs_dec_->clone();

}

UnInitiated &UnInitiated::operator=(const UnInitiated & other)
{
  UnInitiated tmp(other);
  swap(tmp);
  return *this;
}

void UnInitiated::swap(UnInitiated & other)
{
  std::swap(dir_abs_dec_, other.dir_abs_dec_);

}

UnInitiated::~UnInitiated()
{
  delete(dir_abs_dec_);

}

void UnInitiated::accept(Visitor *v)
{
  v->visitUnInitiated(this);
}

UnInitiated *UnInitiated::clone() const
{
  return new UnInitiated(*this);
}



/********************   Initiated    ********************/
Initiated::Initiated(Dir_abs_dec *p1, Constant_expression *p2)
{
  dir_abs_dec_ = p1;
  constant_expression_ = p2;

}

Initiated::Initiated(const Initiated & other)
{
  dir_abs_dec_ = other.dir_abs_dec_->clone();
  constant_expression_ = other.constant_expression_->clone();

}

Initiated &Initiated::operator=(const Initiated & other)
{
  Initiated tmp(other);
  swap(tmp);
  return *this;
}

void Initiated::swap(Initiated & other)
{
  std::swap(dir_abs_dec_, other.dir_abs_dec_);
  std::swap(constant_expression_, other.constant_expression_);

}

Initiated::~Initiated()
{
  delete(dir_abs_dec_);
  delete(constant_expression_);

}

void Initiated::accept(Visitor *v)
{
  v->visitInitiated(this);
}

Initiated *Initiated::clone() const
{
  return new Initiated(*this);
}



/********************   OldFunction    ********************/
OldFunction::OldFunction()
{

}

OldFunction::OldFunction(const OldFunction & other)
{

}

OldFunction &OldFunction::operator=(const OldFunction & other)
{
  OldFunction tmp(other);
  swap(tmp);
  return *this;
}

void OldFunction::swap(OldFunction & other)
{

}

OldFunction::~OldFunction()
{

}

void OldFunction::accept(Visitor *v)
{
  v->visitOldFunction(this);
}

OldFunction *OldFunction::clone() const
{
  return new OldFunction(*this);
}



/********************   NewFunction    ********************/
NewFunction::NewFunction(Parameter_type *p1)
{
  parameter_type_ = p1;

}

NewFunction::NewFunction(const NewFunction & other)
{
  parameter_type_ = other.parameter_type_->clone();

}

NewFunction &NewFunction::operator=(const NewFunction & other)
{
  NewFunction tmp(other);
  swap(tmp);
  return *this;
}

void NewFunction::swap(NewFunction & other)
{
  std::swap(parameter_type_, other.parameter_type_);

}

NewFunction::~NewFunction()
{
  delete(parameter_type_);

}

void NewFunction::accept(Visitor *v)
{
  v->visitNewFunction(this);
}

NewFunction *NewFunction::clone() const
{
  return new NewFunction(*this);
}



/********************   OldFuncExpr    ********************/
OldFuncExpr::OldFuncExpr(Dir_abs_dec *p1)
{
  dir_abs_dec_ = p1;

}

OldFuncExpr::OldFuncExpr(const OldFuncExpr & other)
{
  dir_abs_dec_ = other.dir_abs_dec_->clone();

}

OldFuncExpr &OldFuncExpr::operator=(const OldFuncExpr & other)
{
  OldFuncExpr tmp(other);
  swap(tmp);
  return *this;
}

void OldFuncExpr::swap(OldFuncExpr & other)
{
  std::swap(dir_abs_dec_, other.dir_abs_dec_);

}

OldFuncExpr::~OldFuncExpr()
{
  delete(dir_abs_dec_);

}

void OldFuncExpr::accept(Visitor *v)
{
  v->visitOldFuncExpr(this);
}

OldFuncExpr *OldFuncExpr::clone() const
{
  return new OldFuncExpr(*this);
}



/********************   NewFuncExpr    ********************/
NewFuncExpr::NewFuncExpr(Dir_abs_dec *p1, Parameter_type *p2)
{
  dir_abs_dec_ = p1;
  parameter_type_ = p2;

}

NewFuncExpr::NewFuncExpr(const NewFuncExpr & other)
{
  dir_abs_dec_ = other.dir_abs_dec_->clone();
  parameter_type_ = other.parameter_type_->clone();

}

NewFuncExpr &NewFuncExpr::operator=(const NewFuncExpr & other)
{
  NewFuncExpr tmp(other);
  swap(tmp);
  return *this;
}

void NewFuncExpr::swap(NewFuncExpr & other)
{
  std::swap(dir_abs_dec_, other.dir_abs_dec_);
  std::swap(parameter_type_, other.parameter_type_);

}

NewFuncExpr::~NewFuncExpr()
{
  delete(dir_abs_dec_);
  delete(parameter_type_);

}

void NewFuncExpr::accept(Visitor *v)
{
  v->visitNewFuncExpr(this);
}

NewFuncExpr *NewFuncExpr::clone() const
{
  return new NewFuncExpr(*this);
}



/********************   LabelS    ********************/
LabelS::LabelS(Labeled_stm *p1)
{
  labeled_stm_ = p1;

}

LabelS::LabelS(const LabelS & other)
{
  labeled_stm_ = other.labeled_stm_->clone();

}

LabelS &LabelS::operator=(const LabelS & other)
{
  LabelS tmp(other);
  swap(tmp);
  return *this;
}

void LabelS::swap(LabelS & other)
{
  std::swap(labeled_stm_, other.labeled_stm_);

}

LabelS::~LabelS()
{
  delete(labeled_stm_);

}

void LabelS::accept(Visitor *v)
{
  v->visitLabelS(this);
}

LabelS *LabelS::clone() const
{
  return new LabelS(*this);
}



/********************   CompS    ********************/
CompS::CompS(Compound_stm *p1)
{
  compound_stm_ = p1;

}

CompS::CompS(const CompS & other)
{
  compound_stm_ = other.compound_stm_->clone();

}

CompS &CompS::operator=(const CompS & other)
{
  CompS tmp(other);
  swap(tmp);
  return *this;
}

void CompS::swap(CompS & other)
{
  std::swap(compound_stm_, other.compound_stm_);

}

CompS::~CompS()
{
  delete(compound_stm_);

}

void CompS::accept(Visitor *v)
{
  v->visitCompS(this);
}

CompS *CompS::clone() const
{
  return new CompS(*this);
}



/********************   ExprS    ********************/
ExprS::ExprS(Expression_stm *p1)
{
  expression_stm_ = p1;

}

ExprS::ExprS(const ExprS & other)
{
  expression_stm_ = other.expression_stm_->clone();

}

ExprS &ExprS::operator=(const ExprS & other)
{
  ExprS tmp(other);
  swap(tmp);
  return *this;
}

void ExprS::swap(ExprS & other)
{
  std::swap(expression_stm_, other.expression_stm_);

}

ExprS::~ExprS()
{
  delete(expression_stm_);

}

void ExprS::accept(Visitor *v)
{
  v->visitExprS(this);
}

ExprS *ExprS::clone() const
{
  return new ExprS(*this);
}



/********************   SelS    ********************/
SelS::SelS(Selection_stm *p1)
{
  selection_stm_ = p1;

}

SelS::SelS(const SelS & other)
{
  selection_stm_ = other.selection_stm_->clone();

}

SelS &SelS::operator=(const SelS & other)
{
  SelS tmp(other);
  swap(tmp);
  return *this;
}

void SelS::swap(SelS & other)
{
  std::swap(selection_stm_, other.selection_stm_);

}

SelS::~SelS()
{
  delete(selection_stm_);

}

void SelS::accept(Visitor *v)
{
  v->visitSelS(this);
}

SelS *SelS::clone() const
{
  return new SelS(*this);
}



/********************   IterS    ********************/
IterS::IterS(Iter_stm *p1)
{
  iter_stm_ = p1;

}

IterS::IterS(const IterS & other)
{
  iter_stm_ = other.iter_stm_->clone();

}

IterS &IterS::operator=(const IterS & other)
{
  IterS tmp(other);
  swap(tmp);
  return *this;
}

void IterS::swap(IterS & other)
{
  std::swap(iter_stm_, other.iter_stm_);

}

IterS::~IterS()
{
  delete(iter_stm_);

}

void IterS::accept(Visitor *v)
{
  v->visitIterS(this);
}

IterS *IterS::clone() const
{
  return new IterS(*this);
}



/********************   JumpS    ********************/
JumpS::JumpS(Jump_stm *p1)
{
  jump_stm_ = p1;

}

JumpS::JumpS(const JumpS & other)
{
  jump_stm_ = other.jump_stm_->clone();

}

JumpS &JumpS::operator=(const JumpS & other)
{
  JumpS tmp(other);
  swap(tmp);
  return *this;
}

void JumpS::swap(JumpS & other)
{
  std::swap(jump_stm_, other.jump_stm_);

}

JumpS::~JumpS()
{
  delete(jump_stm_);

}

void JumpS::accept(Visitor *v)
{
  v->visitJumpS(this);
}

JumpS *JumpS::clone() const
{
  return new JumpS(*this);
}



/********************   SlabelOne    ********************/
SlabelOne::SlabelOne(Ident p1, Stm *p2)
{
  ident_ = p1;
  stm_ = p2;

}

SlabelOne::SlabelOne(const SlabelOne & other)
{
  ident_ = other.ident_;
  stm_ = other.stm_->clone();

}

SlabelOne &SlabelOne::operator=(const SlabelOne & other)
{
  SlabelOne tmp(other);
  swap(tmp);
  return *this;
}

void SlabelOne::swap(SlabelOne & other)
{
  std::swap(ident_, other.ident_);
  std::swap(stm_, other.stm_);

}

SlabelOne::~SlabelOne()
{
  delete(stm_);

}

void SlabelOne::accept(Visitor *v)
{
  v->visitSlabelOne(this);
}

SlabelOne *SlabelOne::clone() const
{
  return new SlabelOne(*this);
}



/********************   SlabelTwo    ********************/
SlabelTwo::SlabelTwo(Constant_expression *p1, Stm *p2)
{
  constant_expression_ = p1;
  stm_ = p2;

}

SlabelTwo::SlabelTwo(const SlabelTwo & other)
{
  constant_expression_ = other.constant_expression_->clone();
  stm_ = other.stm_->clone();

}

SlabelTwo &SlabelTwo::operator=(const SlabelTwo & other)
{
  SlabelTwo tmp(other);
  swap(tmp);
  return *this;
}

void SlabelTwo::swap(SlabelTwo & other)
{
  std::swap(constant_expression_, other.constant_expression_);
  std::swap(stm_, other.stm_);

}

SlabelTwo::~SlabelTwo()
{
  delete(constant_expression_);
  delete(stm_);

}

void SlabelTwo::accept(Visitor *v)
{
  v->visitSlabelTwo(this);
}

SlabelTwo *SlabelTwo::clone() const
{
  return new SlabelTwo(*this);
}



/********************   SlabelThree    ********************/
SlabelThree::SlabelThree(Stm *p1)
{
  stm_ = p1;

}

SlabelThree::SlabelThree(const SlabelThree & other)
{
  stm_ = other.stm_->clone();

}

SlabelThree &SlabelThree::operator=(const SlabelThree & other)
{
  SlabelThree tmp(other);
  swap(tmp);
  return *this;
}

void SlabelThree::swap(SlabelThree & other)
{
  std::swap(stm_, other.stm_);

}

SlabelThree::~SlabelThree()
{
  delete(stm_);

}

void SlabelThree::accept(Visitor *v)
{
  v->visitSlabelThree(this);
}

SlabelThree *SlabelThree::clone() const
{
  return new SlabelThree(*this);
}



/********************   ScompOne    ********************/
ScompOne::ScompOne()
{

}

ScompOne::ScompOne(const ScompOne & other)
{

}

ScompOne &ScompOne::operator=(const ScompOne & other)
{
  ScompOne tmp(other);
  swap(tmp);
  return *this;
}

void ScompOne::swap(ScompOne & other)
{

}

ScompOne::~ScompOne()
{

}

void ScompOne::accept(Visitor *v)
{
  v->visitScompOne(this);
}

ScompOne *ScompOne::clone() const
{
  return new ScompOne(*this);
}



/********************   ScompTwo    ********************/
ScompTwo::ScompTwo(ListStm *p1)
{
  liststm_ = p1;

}

ScompTwo::ScompTwo(const ScompTwo & other)
{
  liststm_ = other.liststm_->clone();

}

ScompTwo &ScompTwo::operator=(const ScompTwo & other)
{
  ScompTwo tmp(other);
  swap(tmp);
  return *this;
}

void ScompTwo::swap(ScompTwo & other)
{
  std::swap(liststm_, other.liststm_);

}

ScompTwo::~ScompTwo()
{
  delete(liststm_);

}

void ScompTwo::accept(Visitor *v)
{
  v->visitScompTwo(this);
}

ScompTwo *ScompTwo::clone() const
{
  return new ScompTwo(*this);
}



/********************   ScompThree    ********************/
ScompThree::ScompThree(ListDec *p1)
{
  listdec_ = p1;

}

ScompThree::ScompThree(const ScompThree & other)
{
  listdec_ = other.listdec_->clone();

}

ScompThree &ScompThree::operator=(const ScompThree & other)
{
  ScompThree tmp(other);
  swap(tmp);
  return *this;
}

void ScompThree::swap(ScompThree & other)
{
  std::swap(listdec_, other.listdec_);

}

ScompThree::~ScompThree()
{
  delete(listdec_);

}

void ScompThree::accept(Visitor *v)
{
  v->visitScompThree(this);
}

ScompThree *ScompThree::clone() const
{
  return new ScompThree(*this);
}



/********************   ScompFour    ********************/
ScompFour::ScompFour(ListDec *p1, ListStm *p2)
{
  listdec_ = p1;
  liststm_ = p2;

}

ScompFour::ScompFour(const ScompFour & other)
{
  listdec_ = other.listdec_->clone();
  liststm_ = other.liststm_->clone();

}

ScompFour &ScompFour::operator=(const ScompFour & other)
{
  ScompFour tmp(other);
  swap(tmp);
  return *this;
}

void ScompFour::swap(ScompFour & other)
{
  std::swap(listdec_, other.listdec_);
  std::swap(liststm_, other.liststm_);

}

ScompFour::~ScompFour()
{
  delete(listdec_);
  delete(liststm_);

}

void ScompFour::accept(Visitor *v)
{
  v->visitScompFour(this);
}

ScompFour *ScompFour::clone() const
{
  return new ScompFour(*this);
}



/********************   SexprOne    ********************/
SexprOne::SexprOne()
{

}

SexprOne::SexprOne(const SexprOne & other)
{

}

SexprOne &SexprOne::operator=(const SexprOne & other)
{
  SexprOne tmp(other);
  swap(tmp);
  return *this;
}

void SexprOne::swap(SexprOne & other)
{

}

SexprOne::~SexprOne()
{

}

void SexprOne::accept(Visitor *v)
{
  v->visitSexprOne(this);
}

SexprOne *SexprOne::clone() const
{
  return new SexprOne(*this);
}



/********************   SexprTwo    ********************/
SexprTwo::SexprTwo(Exp *p1)
{
  exp_ = p1;

}

SexprTwo::SexprTwo(const SexprTwo & other)
{
  exp_ = other.exp_->clone();

}

SexprTwo &SexprTwo::operator=(const SexprTwo & other)
{
  SexprTwo tmp(other);
  swap(tmp);
  return *this;
}

void SexprTwo::swap(SexprTwo & other)
{
  std::swap(exp_, other.exp_);

}

SexprTwo::~SexprTwo()
{
  delete(exp_);

}

void SexprTwo::accept(Visitor *v)
{
  v->visitSexprTwo(this);
}

SexprTwo *SexprTwo::clone() const
{
  return new SexprTwo(*this);
}



/********************   SselOne    ********************/
SselOne::SselOne(Exp *p1, Stm *p2)
{
  exp_ = p1;
  stm_ = p2;

}

SselOne::SselOne(const SselOne & other)
{
  exp_ = other.exp_->clone();
  stm_ = other.stm_->clone();

}

SselOne &SselOne::operator=(const SselOne & other)
{
  SselOne tmp(other);
  swap(tmp);
  return *this;
}

void SselOne::swap(SselOne & other)
{
  std::swap(exp_, other.exp_);
  std::swap(stm_, other.stm_);

}

SselOne::~SselOne()
{
  delete(exp_);
  delete(stm_);

}

void SselOne::accept(Visitor *v)
{
  v->visitSselOne(this);
}

SselOne *SselOne::clone() const
{
  return new SselOne(*this);
}



/********************   SselTwo    ********************/
SselTwo::SselTwo(Exp *p1, Stm *p2, Stm *p3)
{
  exp_ = p1;
  stm_1 = p2;
  stm_2 = p3;

}

SselTwo::SselTwo(const SselTwo & other)
{
  exp_ = other.exp_->clone();
  stm_1 = other.stm_1->clone();
  stm_2 = other.stm_2->clone();

}

SselTwo &SselTwo::operator=(const SselTwo & other)
{
  SselTwo tmp(other);
  swap(tmp);
  return *this;
}

void SselTwo::swap(SselTwo & other)
{
  std::swap(exp_, other.exp_);
  std::swap(stm_1, other.stm_1);
  std::swap(stm_2, other.stm_2);

}

SselTwo::~SselTwo()
{
  delete(exp_);
  delete(stm_1);
  delete(stm_2);

}

void SselTwo::accept(Visitor *v)
{
  v->visitSselTwo(this);
}

SselTwo *SselTwo::clone() const
{
  return new SselTwo(*this);
}



/********************   SselThree    ********************/
SselThree::SselThree(Exp *p1, Stm *p2)
{
  exp_ = p1;
  stm_ = p2;

}

SselThree::SselThree(const SselThree & other)
{
  exp_ = other.exp_->clone();
  stm_ = other.stm_->clone();

}

SselThree &SselThree::operator=(const SselThree & other)
{
  SselThree tmp(other);
  swap(tmp);
  return *this;
}

void SselThree::swap(SselThree & other)
{
  std::swap(exp_, other.exp_);
  std::swap(stm_, other.stm_);

}

SselThree::~SselThree()
{
  delete(exp_);
  delete(stm_);

}

void SselThree::accept(Visitor *v)
{
  v->visitSselThree(this);
}

SselThree *SselThree::clone() const
{
  return new SselThree(*this);
}



/********************   SiterOne    ********************/
SiterOne::SiterOne(Exp *p1, Stm *p2)
{
  exp_ = p1;
  stm_ = p2;

}

SiterOne::SiterOne(const SiterOne & other)
{
  exp_ = other.exp_->clone();
  stm_ = other.stm_->clone();

}

SiterOne &SiterOne::operator=(const SiterOne & other)
{
  SiterOne tmp(other);
  swap(tmp);
  return *this;
}

void SiterOne::swap(SiterOne & other)
{
  std::swap(exp_, other.exp_);
  std::swap(stm_, other.stm_);

}

SiterOne::~SiterOne()
{
  delete(exp_);
  delete(stm_);

}

void SiterOne::accept(Visitor *v)
{
  v->visitSiterOne(this);
}

SiterOne *SiterOne::clone() const
{
  return new SiterOne(*this);
}



/********************   SiterTwo    ********************/
SiterTwo::SiterTwo(Stm *p1, Exp *p2)
{
  stm_ = p1;
  exp_ = p2;

}

SiterTwo::SiterTwo(const SiterTwo & other)
{
  stm_ = other.stm_->clone();
  exp_ = other.exp_->clone();

}

SiterTwo &SiterTwo::operator=(const SiterTwo & other)
{
  SiterTwo tmp(other);
  swap(tmp);
  return *this;
}

void SiterTwo::swap(SiterTwo & other)
{
  std::swap(stm_, other.stm_);
  std::swap(exp_, other.exp_);

}

SiterTwo::~SiterTwo()
{
  delete(stm_);
  delete(exp_);

}

void SiterTwo::accept(Visitor *v)
{
  v->visitSiterTwo(this);
}

SiterTwo *SiterTwo::clone() const
{
  return new SiterTwo(*this);
}



/********************   SiterThree    ********************/
SiterThree::SiterThree(Expression_stm *p1, Expression_stm *p2, Stm *p3)
{
  expression_stm_1 = p1;
  expression_stm_2 = p2;
  stm_ = p3;

}

SiterThree::SiterThree(const SiterThree & other)
{
  expression_stm_1 = other.expression_stm_1->clone();
  expression_stm_2 = other.expression_stm_2->clone();
  stm_ = other.stm_->clone();

}

SiterThree &SiterThree::operator=(const SiterThree & other)
{
  SiterThree tmp(other);
  swap(tmp);
  return *this;
}

void SiterThree::swap(SiterThree & other)
{
  std::swap(expression_stm_1, other.expression_stm_1);
  std::swap(expression_stm_2, other.expression_stm_2);
  std::swap(stm_, other.stm_);

}

SiterThree::~SiterThree()
{
  delete(expression_stm_1);
  delete(expression_stm_2);
  delete(stm_);

}

void SiterThree::accept(Visitor *v)
{
  v->visitSiterThree(this);
}

SiterThree *SiterThree::clone() const
{
  return new SiterThree(*this);
}



/********************   SiterFour    ********************/
SiterFour::SiterFour(Expression_stm *p1, Expression_stm *p2, Exp *p3, Stm *p4)
{
  expression_stm_1 = p1;
  expression_stm_2 = p2;
  exp_ = p3;
  stm_ = p4;

}

SiterFour::SiterFour(const SiterFour & other)
{
  expression_stm_1 = other.expression_stm_1->clone();
  expression_stm_2 = other.expression_stm_2->clone();
  exp_ = other.exp_->clone();
  stm_ = other.stm_->clone();

}

SiterFour &SiterFour::operator=(const SiterFour & other)
{
  SiterFour tmp(other);
  swap(tmp);
  return *this;
}

void SiterFour::swap(SiterFour & other)
{
  std::swap(expression_stm_1, other.expression_stm_1);
  std::swap(expression_stm_2, other.expression_stm_2);
  std::swap(exp_, other.exp_);
  std::swap(stm_, other.stm_);

}

SiterFour::~SiterFour()
{
  delete(expression_stm_1);
  delete(expression_stm_2);
  delete(exp_);
  delete(stm_);

}

void SiterFour::accept(Visitor *v)
{
  v->visitSiterFour(this);
}

SiterFour *SiterFour::clone() const
{
  return new SiterFour(*this);
}



/********************   SjumpOne    ********************/
SjumpOne::SjumpOne(Ident p1)
{
  ident_ = p1;

}

SjumpOne::SjumpOne(const SjumpOne & other)
{
  ident_ = other.ident_;

}

SjumpOne &SjumpOne::operator=(const SjumpOne & other)
{
  SjumpOne tmp(other);
  swap(tmp);
  return *this;
}

void SjumpOne::swap(SjumpOne & other)
{
  std::swap(ident_, other.ident_);

}

SjumpOne::~SjumpOne()
{

}

void SjumpOne::accept(Visitor *v)
{
  v->visitSjumpOne(this);
}

SjumpOne *SjumpOne::clone() const
{
  return new SjumpOne(*this);
}



/********************   SjumpTwo    ********************/
SjumpTwo::SjumpTwo()
{

}

SjumpTwo::SjumpTwo(const SjumpTwo & other)
{

}

SjumpTwo &SjumpTwo::operator=(const SjumpTwo & other)
{
  SjumpTwo tmp(other);
  swap(tmp);
  return *this;
}

void SjumpTwo::swap(SjumpTwo & other)
{

}

SjumpTwo::~SjumpTwo()
{

}

void SjumpTwo::accept(Visitor *v)
{
  v->visitSjumpTwo(this);
}

SjumpTwo *SjumpTwo::clone() const
{
  return new SjumpTwo(*this);
}



/********************   SjumpThree    ********************/
SjumpThree::SjumpThree()
{

}

SjumpThree::SjumpThree(const SjumpThree & other)
{

}

SjumpThree &SjumpThree::operator=(const SjumpThree & other)
{
  SjumpThree tmp(other);
  swap(tmp);
  return *this;
}

void SjumpThree::swap(SjumpThree & other)
{

}

SjumpThree::~SjumpThree()
{

}

void SjumpThree::accept(Visitor *v)
{
  v->visitSjumpThree(this);
}

SjumpThree *SjumpThree::clone() const
{
  return new SjumpThree(*this);
}



/********************   SjumpFour    ********************/
SjumpFour::SjumpFour()
{

}

SjumpFour::SjumpFour(const SjumpFour & other)
{

}

SjumpFour &SjumpFour::operator=(const SjumpFour & other)
{
  SjumpFour tmp(other);
  swap(tmp);
  return *this;
}

void SjumpFour::swap(SjumpFour & other)
{

}

SjumpFour::~SjumpFour()
{

}

void SjumpFour::accept(Visitor *v)
{
  v->visitSjumpFour(this);
}

SjumpFour *SjumpFour::clone() const
{
  return new SjumpFour(*this);
}



/********************   SjumpFive    ********************/
SjumpFive::SjumpFive(Exp *p1)
{
  exp_ = p1;

}

SjumpFive::SjumpFive(const SjumpFive & other)
{
  exp_ = other.exp_->clone();

}

SjumpFive &SjumpFive::operator=(const SjumpFive & other)
{
  SjumpFive tmp(other);
  swap(tmp);
  return *this;
}

void SjumpFive::swap(SjumpFive & other)
{
  std::swap(exp_, other.exp_);

}

SjumpFive::~SjumpFive()
{
  delete(exp_);

}

void SjumpFive::accept(Visitor *v)
{
  v->visitSjumpFive(this);
}

SjumpFive *SjumpFive::clone() const
{
  return new SjumpFive(*this);
}



/********************   Ecomma    ********************/
Ecomma::Ecomma(Exp *p1, Exp *p2)
{
  exp_1 = p1;
  exp_2 = p2;

}

Ecomma::Ecomma(const Ecomma & other)
{
  exp_1 = other.exp_1->clone();
  exp_2 = other.exp_2->clone();

}

Ecomma &Ecomma::operator=(const Ecomma & other)
{
  Ecomma tmp(other);
  swap(tmp);
  return *this;
}

void Ecomma::swap(Ecomma & other)
{
  std::swap(exp_1, other.exp_1);
  std::swap(exp_2, other.exp_2);

}

Ecomma::~Ecomma()
{
  delete(exp_1);
  delete(exp_2);

}

void Ecomma::accept(Visitor *v)
{
  v->visitEcomma(this);
}

Ecomma *Ecomma::clone() const
{
  return new Ecomma(*this);
}



/********************   Eassign    ********************/
Eassign::Eassign(Exp *p1, Assignment_op *p2, Exp *p3)
{
  exp_1 = p1;
  assignment_op_ = p2;
  exp_2 = p3;

}

Eassign::Eassign(const Eassign & other)
{
  exp_1 = other.exp_1->clone();
  assignment_op_ = other.assignment_op_->clone();
  exp_2 = other.exp_2->clone();

}

Eassign &Eassign::operator=(const Eassign & other)
{
  Eassign tmp(other);
  swap(tmp);
  return *this;
}

void Eassign::swap(Eassign & other)
{
  std::swap(exp_1, other.exp_1);
  std::swap(assignment_op_, other.assignment_op_);
  std::swap(exp_2, other.exp_2);

}

Eassign::~Eassign()
{
  delete(exp_1);
  delete(assignment_op_);
  delete(exp_2);

}

void Eassign::accept(Visitor *v)
{
  v->visitEassign(this);
}

Eassign *Eassign::clone() const
{
  return new Eassign(*this);
}



/********************   Econdition    ********************/
Econdition::Econdition(Exp *p1, Exp *p2, Exp *p3)
{
  exp_1 = p1;
  exp_2 = p2;
  exp_3 = p3;

}

Econdition::Econdition(const Econdition & other)
{
  exp_1 = other.exp_1->clone();
  exp_2 = other.exp_2->clone();
  exp_3 = other.exp_3->clone();

}

Econdition &Econdition::operator=(const Econdition & other)
{
  Econdition tmp(other);
  swap(tmp);
  return *this;
}

void Econdition::swap(Econdition & other)
{
  std::swap(exp_1, other.exp_1);
  std::swap(exp_2, other.exp_2);
  std::swap(exp_3, other.exp_3);

}

Econdition::~Econdition()
{
  delete(exp_1);
  delete(exp_2);
  delete(exp_3);

}

void Econdition::accept(Visitor *v)
{
  v->visitEcondition(this);
}

Econdition *Econdition::clone() const
{
  return new Econdition(*this);
}



/********************   Elor    ********************/
Elor::Elor(Exp *p1, Exp *p2)
{
  exp_1 = p1;
  exp_2 = p2;

}

Elor::Elor(const Elor & other)
{
  exp_1 = other.exp_1->clone();
  exp_2 = other.exp_2->clone();

}

Elor &Elor::operator=(const Elor & other)
{
  Elor tmp(other);
  swap(tmp);
  return *this;
}

void Elor::swap(Elor & other)
{
  std::swap(exp_1, other.exp_1);
  std::swap(exp_2, other.exp_2);

}

Elor::~Elor()
{
  delete(exp_1);
  delete(exp_2);

}

void Elor::accept(Visitor *v)
{
  v->visitElor(this);
}

Elor *Elor::clone() const
{
  return new Elor(*this);
}



/********************   Eland    ********************/
Eland::Eland(Exp *p1, Exp *p2)
{
  exp_1 = p1;
  exp_2 = p2;

}

Eland::Eland(const Eland & other)
{
  exp_1 = other.exp_1->clone();
  exp_2 = other.exp_2->clone();

}

Eland &Eland::operator=(const Eland & other)
{
  Eland tmp(other);
  swap(tmp);
  return *this;
}

void Eland::swap(Eland & other)
{
  std::swap(exp_1, other.exp_1);
  std::swap(exp_2, other.exp_2);

}

Eland::~Eland()
{
  delete(exp_1);
  delete(exp_2);

}

void Eland::accept(Visitor *v)
{
  v->visitEland(this);
}

Eland *Eland::clone() const
{
  return new Eland(*this);
}



/********************   Ebitor    ********************/
Ebitor::Ebitor(Exp *p1, Exp *p2)
{
  exp_1 = p1;
  exp_2 = p2;

}

Ebitor::Ebitor(const Ebitor & other)
{
  exp_1 = other.exp_1->clone();
  exp_2 = other.exp_2->clone();

}

Ebitor &Ebitor::operator=(const Ebitor & other)
{
  Ebitor tmp(other);
  swap(tmp);
  return *this;
}

void Ebitor::swap(Ebitor & other)
{
  std::swap(exp_1, other.exp_1);
  std::swap(exp_2, other.exp_2);

}

Ebitor::~Ebitor()
{
  delete(exp_1);
  delete(exp_2);

}

void Ebitor::accept(Visitor *v)
{
  v->visitEbitor(this);
}

Ebitor *Ebitor::clone() const
{
  return new Ebitor(*this);
}



/********************   Ebitexor    ********************/
Ebitexor::Ebitexor(Exp *p1, Exp *p2)
{
  exp_1 = p1;
  exp_2 = p2;

}

Ebitexor::Ebitexor(const Ebitexor & other)
{
  exp_1 = other.exp_1->clone();
  exp_2 = other.exp_2->clone();

}

Ebitexor &Ebitexor::operator=(const Ebitexor & other)
{
  Ebitexor tmp(other);
  swap(tmp);
  return *this;
}

void Ebitexor::swap(Ebitexor & other)
{
  std::swap(exp_1, other.exp_1);
  std::swap(exp_2, other.exp_2);

}

Ebitexor::~Ebitexor()
{
  delete(exp_1);
  delete(exp_2);

}

void Ebitexor::accept(Visitor *v)
{
  v->visitEbitexor(this);
}

Ebitexor *Ebitexor::clone() const
{
  return new Ebitexor(*this);
}



/********************   Ebitand    ********************/
Ebitand::Ebitand(Exp *p1, Exp *p2)
{
  exp_1 = p1;
  exp_2 = p2;

}

Ebitand::Ebitand(const Ebitand & other)
{
  exp_1 = other.exp_1->clone();
  exp_2 = other.exp_2->clone();

}

Ebitand &Ebitand::operator=(const Ebitand & other)
{
  Ebitand tmp(other);
  swap(tmp);
  return *this;
}

void Ebitand::swap(Ebitand & other)
{
  std::swap(exp_1, other.exp_1);
  std::swap(exp_2, other.exp_2);

}

Ebitand::~Ebitand()
{
  delete(exp_1);
  delete(exp_2);

}

void Ebitand::accept(Visitor *v)
{
  v->visitEbitand(this);
}

Ebitand *Ebitand::clone() const
{
  return new Ebitand(*this);
}



/********************   Eeq    ********************/
Eeq::Eeq(Exp *p1, Exp *p2)
{
  exp_1 = p1;
  exp_2 = p2;

}

Eeq::Eeq(const Eeq & other)
{
  exp_1 = other.exp_1->clone();
  exp_2 = other.exp_2->clone();

}

Eeq &Eeq::operator=(const Eeq & other)
{
  Eeq tmp(other);
  swap(tmp);
  return *this;
}

void Eeq::swap(Eeq & other)
{
  std::swap(exp_1, other.exp_1);
  std::swap(exp_2, other.exp_2);

}

Eeq::~Eeq()
{
  delete(exp_1);
  delete(exp_2);

}

void Eeq::accept(Visitor *v)
{
  v->visitEeq(this);
}

Eeq *Eeq::clone() const
{
  return new Eeq(*this);
}



/********************   Eneq    ********************/
Eneq::Eneq(Exp *p1, Exp *p2)
{
  exp_1 = p1;
  exp_2 = p2;

}

Eneq::Eneq(const Eneq & other)
{
  exp_1 = other.exp_1->clone();
  exp_2 = other.exp_2->clone();

}

Eneq &Eneq::operator=(const Eneq & other)
{
  Eneq tmp(other);
  swap(tmp);
  return *this;
}

void Eneq::swap(Eneq & other)
{
  std::swap(exp_1, other.exp_1);
  std::swap(exp_2, other.exp_2);

}

Eneq::~Eneq()
{
  delete(exp_1);
  delete(exp_2);

}

void Eneq::accept(Visitor *v)
{
  v->visitEneq(this);
}

Eneq *Eneq::clone() const
{
  return new Eneq(*this);
}



/********************   Elthen    ********************/
Elthen::Elthen(Exp *p1, Exp *p2)
{
  exp_1 = p1;
  exp_2 = p2;

}

Elthen::Elthen(const Elthen & other)
{
  exp_1 = other.exp_1->clone();
  exp_2 = other.exp_2->clone();

}

Elthen &Elthen::operator=(const Elthen & other)
{
  Elthen tmp(other);
  swap(tmp);
  return *this;
}

void Elthen::swap(Elthen & other)
{
  std::swap(exp_1, other.exp_1);
  std::swap(exp_2, other.exp_2);

}

Elthen::~Elthen()
{
  delete(exp_1);
  delete(exp_2);

}

void Elthen::accept(Visitor *v)
{
  v->visitElthen(this);
}

Elthen *Elthen::clone() const
{
  return new Elthen(*this);
}



/********************   Egrthen    ********************/
Egrthen::Egrthen(Exp *p1, Exp *p2)
{
  exp_1 = p1;
  exp_2 = p2;

}

Egrthen::Egrthen(const Egrthen & other)
{
  exp_1 = other.exp_1->clone();
  exp_2 = other.exp_2->clone();

}

Egrthen &Egrthen::operator=(const Egrthen & other)
{
  Egrthen tmp(other);
  swap(tmp);
  return *this;
}

void Egrthen::swap(Egrthen & other)
{
  std::swap(exp_1, other.exp_1);
  std::swap(exp_2, other.exp_2);

}

Egrthen::~Egrthen()
{
  delete(exp_1);
  delete(exp_2);

}

void Egrthen::accept(Visitor *v)
{
  v->visitEgrthen(this);
}

Egrthen *Egrthen::clone() const
{
  return new Egrthen(*this);
}



/********************   Ele    ********************/
Ele::Ele(Exp *p1, Exp *p2)
{
  exp_1 = p1;
  exp_2 = p2;

}

Ele::Ele(const Ele & other)
{
  exp_1 = other.exp_1->clone();
  exp_2 = other.exp_2->clone();

}

Ele &Ele::operator=(const Ele & other)
{
  Ele tmp(other);
  swap(tmp);
  return *this;
}

void Ele::swap(Ele & other)
{
  std::swap(exp_1, other.exp_1);
  std::swap(exp_2, other.exp_2);

}

Ele::~Ele()
{
  delete(exp_1);
  delete(exp_2);

}

void Ele::accept(Visitor *v)
{
  v->visitEle(this);
}

Ele *Ele::clone() const
{
  return new Ele(*this);
}



/********************   Ege    ********************/
Ege::Ege(Exp *p1, Exp *p2)
{
  exp_1 = p1;
  exp_2 = p2;

}

Ege::Ege(const Ege & other)
{
  exp_1 = other.exp_1->clone();
  exp_2 = other.exp_2->clone();

}

Ege &Ege::operator=(const Ege & other)
{
  Ege tmp(other);
  swap(tmp);
  return *this;
}

void Ege::swap(Ege & other)
{
  std::swap(exp_1, other.exp_1);
  std::swap(exp_2, other.exp_2);

}

Ege::~Ege()
{
  delete(exp_1);
  delete(exp_2);

}

void Ege::accept(Visitor *v)
{
  v->visitEge(this);
}

Ege *Ege::clone() const
{
  return new Ege(*this);
}



/********************   Eleft    ********************/
Eleft::Eleft(Exp *p1, Exp *p2)
{
  exp_1 = p1;
  exp_2 = p2;

}

Eleft::Eleft(const Eleft & other)
{
  exp_1 = other.exp_1->clone();
  exp_2 = other.exp_2->clone();

}

Eleft &Eleft::operator=(const Eleft & other)
{
  Eleft tmp(other);
  swap(tmp);
  return *this;
}

void Eleft::swap(Eleft & other)
{
  std::swap(exp_1, other.exp_1);
  std::swap(exp_2, other.exp_2);

}

Eleft::~Eleft()
{
  delete(exp_1);
  delete(exp_2);

}

void Eleft::accept(Visitor *v)
{
  v->visitEleft(this);
}

Eleft *Eleft::clone() const
{
  return new Eleft(*this);
}



/********************   Eright    ********************/
Eright::Eright(Exp *p1, Exp *p2)
{
  exp_1 = p1;
  exp_2 = p2;

}

Eright::Eright(const Eright & other)
{
  exp_1 = other.exp_1->clone();
  exp_2 = other.exp_2->clone();

}

Eright &Eright::operator=(const Eright & other)
{
  Eright tmp(other);
  swap(tmp);
  return *this;
}

void Eright::swap(Eright & other)
{
  std::swap(exp_1, other.exp_1);
  std::swap(exp_2, other.exp_2);

}

Eright::~Eright()
{
  delete(exp_1);
  delete(exp_2);

}

void Eright::accept(Visitor *v)
{
  v->visitEright(this);
}

Eright *Eright::clone() const
{
  return new Eright(*this);
}



/********************   Eplus    ********************/
Eplus::Eplus(Exp *p1, Exp *p2)
{
  exp_1 = p1;
  exp_2 = p2;

}

Eplus::Eplus(const Eplus & other)
{
  exp_1 = other.exp_1->clone();
  exp_2 = other.exp_2->clone();

}

Eplus &Eplus::operator=(const Eplus & other)
{
  Eplus tmp(other);
  swap(tmp);
  return *this;
}

void Eplus::swap(Eplus & other)
{
  std::swap(exp_1, other.exp_1);
  std::swap(exp_2, other.exp_2);

}

Eplus::~Eplus()
{
  delete(exp_1);
  delete(exp_2);

}

void Eplus::accept(Visitor *v)
{
  v->visitEplus(this);
}

Eplus *Eplus::clone() const
{
  return new Eplus(*this);
}



/********************   Eminus    ********************/
Eminus::Eminus(Exp *p1, Exp *p2)
{
  exp_1 = p1;
  exp_2 = p2;

}

Eminus::Eminus(const Eminus & other)
{
  exp_1 = other.exp_1->clone();
  exp_2 = other.exp_2->clone();

}

Eminus &Eminus::operator=(const Eminus & other)
{
  Eminus tmp(other);
  swap(tmp);
  return *this;
}

void Eminus::swap(Eminus & other)
{
  std::swap(exp_1, other.exp_1);
  std::swap(exp_2, other.exp_2);

}

Eminus::~Eminus()
{
  delete(exp_1);
  delete(exp_2);

}

void Eminus::accept(Visitor *v)
{
  v->visitEminus(this);
}

Eminus *Eminus::clone() const
{
  return new Eminus(*this);
}



/********************   Etimes    ********************/
Etimes::Etimes(Exp *p1, Exp *p2)
{
  exp_1 = p1;
  exp_2 = p2;

}

Etimes::Etimes(const Etimes & other)
{
  exp_1 = other.exp_1->clone();
  exp_2 = other.exp_2->clone();

}

Etimes &Etimes::operator=(const Etimes & other)
{
  Etimes tmp(other);
  swap(tmp);
  return *this;
}

void Etimes::swap(Etimes & other)
{
  std::swap(exp_1, other.exp_1);
  std::swap(exp_2, other.exp_2);

}

Etimes::~Etimes()
{
  delete(exp_1);
  delete(exp_2);

}

void Etimes::accept(Visitor *v)
{
  v->visitEtimes(this);
}

Etimes *Etimes::clone() const
{
  return new Etimes(*this);
}



/********************   Ediv    ********************/
Ediv::Ediv(Exp *p1, Exp *p2)
{
  exp_1 = p1;
  exp_2 = p2;

}

Ediv::Ediv(const Ediv & other)
{
  exp_1 = other.exp_1->clone();
  exp_2 = other.exp_2->clone();

}

Ediv &Ediv::operator=(const Ediv & other)
{
  Ediv tmp(other);
  swap(tmp);
  return *this;
}

void Ediv::swap(Ediv & other)
{
  std::swap(exp_1, other.exp_1);
  std::swap(exp_2, other.exp_2);

}

Ediv::~Ediv()
{
  delete(exp_1);
  delete(exp_2);

}

void Ediv::accept(Visitor *v)
{
  v->visitEdiv(this);
}

Ediv *Ediv::clone() const
{
  return new Ediv(*this);
}



/********************   Emod    ********************/
Emod::Emod(Exp *p1, Exp *p2)
{
  exp_1 = p1;
  exp_2 = p2;

}

Emod::Emod(const Emod & other)
{
  exp_1 = other.exp_1->clone();
  exp_2 = other.exp_2->clone();

}

Emod &Emod::operator=(const Emod & other)
{
  Emod tmp(other);
  swap(tmp);
  return *this;
}

void Emod::swap(Emod & other)
{
  std::swap(exp_1, other.exp_1);
  std::swap(exp_2, other.exp_2);

}

Emod::~Emod()
{
  delete(exp_1);
  delete(exp_2);

}

void Emod::accept(Visitor *v)
{
  v->visitEmod(this);
}

Emod *Emod::clone() const
{
  return new Emod(*this);
}



/********************   Etypeconv    ********************/
Etypeconv::Etypeconv(Type_name *p1, Exp *p2)
{
  type_name_ = p1;
  exp_ = p2;

}

Etypeconv::Etypeconv(const Etypeconv & other)
{
  type_name_ = other.type_name_->clone();
  exp_ = other.exp_->clone();

}

Etypeconv &Etypeconv::operator=(const Etypeconv & other)
{
  Etypeconv tmp(other);
  swap(tmp);
  return *this;
}

void Etypeconv::swap(Etypeconv & other)
{
  std::swap(type_name_, other.type_name_);
  std::swap(exp_, other.exp_);

}

Etypeconv::~Etypeconv()
{
  delete(type_name_);
  delete(exp_);

}

void Etypeconv::accept(Visitor *v)
{
  v->visitEtypeconv(this);
}

Etypeconv *Etypeconv::clone() const
{
  return new Etypeconv(*this);
}



/********************   Epreinc    ********************/
Epreinc::Epreinc(Exp *p1)
{
  exp_ = p1;

}

Epreinc::Epreinc(const Epreinc & other)
{
  exp_ = other.exp_->clone();

}

Epreinc &Epreinc::operator=(const Epreinc & other)
{
  Epreinc tmp(other);
  swap(tmp);
  return *this;
}

void Epreinc::swap(Epreinc & other)
{
  std::swap(exp_, other.exp_);

}

Epreinc::~Epreinc()
{
  delete(exp_);

}

void Epreinc::accept(Visitor *v)
{
  v->visitEpreinc(this);
}

Epreinc *Epreinc::clone() const
{
  return new Epreinc(*this);
}



/********************   Epredec    ********************/
Epredec::Epredec(Exp *p1)
{
  exp_ = p1;

}

Epredec::Epredec(const Epredec & other)
{
  exp_ = other.exp_->clone();

}

Epredec &Epredec::operator=(const Epredec & other)
{
  Epredec tmp(other);
  swap(tmp);
  return *this;
}

void Epredec::swap(Epredec & other)
{
  std::swap(exp_, other.exp_);

}

Epredec::~Epredec()
{
  delete(exp_);

}

void Epredec::accept(Visitor *v)
{
  v->visitEpredec(this);
}

Epredec *Epredec::clone() const
{
  return new Epredec(*this);
}



/********************   Epreop    ********************/
Epreop::Epreop(Unary_operator *p1, Exp *p2)
{
  unary_operator_ = p1;
  exp_ = p2;

}

Epreop::Epreop(const Epreop & other)
{
  unary_operator_ = other.unary_operator_->clone();
  exp_ = other.exp_->clone();

}

Epreop &Epreop::operator=(const Epreop & other)
{
  Epreop tmp(other);
  swap(tmp);
  return *this;
}

void Epreop::swap(Epreop & other)
{
  std::swap(unary_operator_, other.unary_operator_);
  std::swap(exp_, other.exp_);

}

Epreop::~Epreop()
{
  delete(unary_operator_);
  delete(exp_);

}

void Epreop::accept(Visitor *v)
{
  v->visitEpreop(this);
}

Epreop *Epreop::clone() const
{
  return new Epreop(*this);
}



/********************   Ebytesexpr    ********************/
Ebytesexpr::Ebytesexpr(Exp *p1)
{
  exp_ = p1;

}

Ebytesexpr::Ebytesexpr(const Ebytesexpr & other)
{
  exp_ = other.exp_->clone();

}

Ebytesexpr &Ebytesexpr::operator=(const Ebytesexpr & other)
{
  Ebytesexpr tmp(other);
  swap(tmp);
  return *this;
}

void Ebytesexpr::swap(Ebytesexpr & other)
{
  std::swap(exp_, other.exp_);

}

Ebytesexpr::~Ebytesexpr()
{
  delete(exp_);

}

void Ebytesexpr::accept(Visitor *v)
{
  v->visitEbytesexpr(this);
}

Ebytesexpr *Ebytesexpr::clone() const
{
  return new Ebytesexpr(*this);
}



/********************   Ebytestype    ********************/
Ebytestype::Ebytestype(Type_name *p1)
{
  type_name_ = p1;

}

Ebytestype::Ebytestype(const Ebytestype & other)
{
  type_name_ = other.type_name_->clone();

}

Ebytestype &Ebytestype::operator=(const Ebytestype & other)
{
  Ebytestype tmp(other);
  swap(tmp);
  return *this;
}

void Ebytestype::swap(Ebytestype & other)
{
  std::swap(type_name_, other.type_name_);

}

Ebytestype::~Ebytestype()
{
  delete(type_name_);

}

void Ebytestype::accept(Visitor *v)
{
  v->visitEbytestype(this);
}

Ebytestype *Ebytestype::clone() const
{
  return new Ebytestype(*this);
}



/********************   Earray    ********************/
Earray::Earray(Exp *p1, Exp *p2)
{
  exp_1 = p1;
  exp_2 = p2;

}

Earray::Earray(const Earray & other)
{
  exp_1 = other.exp_1->clone();
  exp_2 = other.exp_2->clone();

}

Earray &Earray::operator=(const Earray & other)
{
  Earray tmp(other);
  swap(tmp);
  return *this;
}

void Earray::swap(Earray & other)
{
  std::swap(exp_1, other.exp_1);
  std::swap(exp_2, other.exp_2);

}

Earray::~Earray()
{
  delete(exp_1);
  delete(exp_2);

}

void Earray::accept(Visitor *v)
{
  v->visitEarray(this);
}

Earray *Earray::clone() const
{
  return new Earray(*this);
}



/********************   Efunk    ********************/
Efunk::Efunk(Exp *p1)
{
  exp_ = p1;

}

Efunk::Efunk(const Efunk & other)
{
  exp_ = other.exp_->clone();

}

Efunk &Efunk::operator=(const Efunk & other)
{
  Efunk tmp(other);
  swap(tmp);
  return *this;
}

void Efunk::swap(Efunk & other)
{
  std::swap(exp_, other.exp_);

}

Efunk::~Efunk()
{
  delete(exp_);

}

void Efunk::accept(Visitor *v)
{
  v->visitEfunk(this);
}

Efunk *Efunk::clone() const
{
  return new Efunk(*this);
}



/********************   Efunkpar    ********************/
Efunkpar::Efunkpar(Exp *p1, ListExp *p2)
{
  exp_ = p1;
  listexp_ = p2;

}

Efunkpar::Efunkpar(const Efunkpar & other)
{
  exp_ = other.exp_->clone();
  listexp_ = other.listexp_->clone();

}

Efunkpar &Efunkpar::operator=(const Efunkpar & other)
{
  Efunkpar tmp(other);
  swap(tmp);
  return *this;
}

void Efunkpar::swap(Efunkpar & other)
{
  std::swap(exp_, other.exp_);
  std::swap(listexp_, other.listexp_);

}

Efunkpar::~Efunkpar()
{
  delete(exp_);
  delete(listexp_);

}

void Efunkpar::accept(Visitor *v)
{
  v->visitEfunkpar(this);
}

Efunkpar *Efunkpar::clone() const
{
  return new Efunkpar(*this);
}



/********************   Eselect    ********************/
Eselect::Eselect(Exp *p1, Ident p2)
{
  exp_ = p1;
  ident_ = p2;

}

Eselect::Eselect(const Eselect & other)
{
  exp_ = other.exp_->clone();
  ident_ = other.ident_;

}

Eselect &Eselect::operator=(const Eselect & other)
{
  Eselect tmp(other);
  swap(tmp);
  return *this;
}

void Eselect::swap(Eselect & other)
{
  std::swap(exp_, other.exp_);
  std::swap(ident_, other.ident_);

}

Eselect::~Eselect()
{
  delete(exp_);

}

void Eselect::accept(Visitor *v)
{
  v->visitEselect(this);
}

Eselect *Eselect::clone() const
{
  return new Eselect(*this);
}



/********************   Epoint    ********************/
Epoint::Epoint(Exp *p1, Ident p2)
{
  exp_ = p1;
  ident_ = p2;

}

Epoint::Epoint(const Epoint & other)
{
  exp_ = other.exp_->clone();
  ident_ = other.ident_;

}

Epoint &Epoint::operator=(const Epoint & other)
{
  Epoint tmp(other);
  swap(tmp);
  return *this;
}

void Epoint::swap(Epoint & other)
{
  std::swap(exp_, other.exp_);
  std::swap(ident_, other.ident_);

}

Epoint::~Epoint()
{
  delete(exp_);

}

void Epoint::accept(Visitor *v)
{
  v->visitEpoint(this);
}

Epoint *Epoint::clone() const
{
  return new Epoint(*this);
}



/********************   Epostinc    ********************/
Epostinc::Epostinc(Exp *p1)
{
  exp_ = p1;

}

Epostinc::Epostinc(const Epostinc & other)
{
  exp_ = other.exp_->clone();

}

Epostinc &Epostinc::operator=(const Epostinc & other)
{
  Epostinc tmp(other);
  swap(tmp);
  return *this;
}

void Epostinc::swap(Epostinc & other)
{
  std::swap(exp_, other.exp_);

}

Epostinc::~Epostinc()
{
  delete(exp_);

}

void Epostinc::accept(Visitor *v)
{
  v->visitEpostinc(this);
}

Epostinc *Epostinc::clone() const
{
  return new Epostinc(*this);
}



/********************   Epostdec    ********************/
Epostdec::Epostdec(Exp *p1)
{
  exp_ = p1;

}

Epostdec::Epostdec(const Epostdec & other)
{
  exp_ = other.exp_->clone();

}

Epostdec &Epostdec::operator=(const Epostdec & other)
{
  Epostdec tmp(other);
  swap(tmp);
  return *this;
}

void Epostdec::swap(Epostdec & other)
{
  std::swap(exp_, other.exp_);

}

Epostdec::~Epostdec()
{
  delete(exp_);

}

void Epostdec::accept(Visitor *v)
{
  v->visitEpostdec(this);
}

Epostdec *Epostdec::clone() const
{
  return new Epostdec(*this);
}



/********************   Evar    ********************/
Evar::Evar(Ident p1)
{
  ident_ = p1;

}

Evar::Evar(const Evar & other)
{
  ident_ = other.ident_;

}

Evar &Evar::operator=(const Evar & other)
{
  Evar tmp(other);
  swap(tmp);
  return *this;
}

void Evar::swap(Evar & other)
{
  std::swap(ident_, other.ident_);

}

Evar::~Evar()
{

}

void Evar::accept(Visitor *v)
{
  v->visitEvar(this);
}

Evar *Evar::clone() const
{
  return new Evar(*this);
}



/********************   Econst    ********************/
Econst::Econst(Constant *p1)
{
  constant_ = p1;

}

Econst::Econst(const Econst & other)
{
  constant_ = other.constant_->clone();

}

Econst &Econst::operator=(const Econst & other)
{
  Econst tmp(other);
  swap(tmp);
  return *this;
}

void Econst::swap(Econst & other)
{
  std::swap(constant_, other.constant_);

}

Econst::~Econst()
{
  delete(constant_);

}

void Econst::accept(Visitor *v)
{
  v->visitEconst(this);
}

Econst *Econst::clone() const
{
  return new Econst(*this);
}



/********************   Estring    ********************/
Estring::Estring(String p1)
{
  string_ = p1;

}

Estring::Estring(const Estring & other)
{
  string_ = other.string_;

}

Estring &Estring::operator=(const Estring & other)
{
  Estring tmp(other);
  swap(tmp);
  return *this;
}

void Estring::swap(Estring & other)
{
  std::swap(string_, other.string_);

}

Estring::~Estring()
{

}

void Estring::accept(Visitor *v)
{
  v->visitEstring(this);
}

Estring *Estring::clone() const
{
  return new Estring(*this);
}



/********************   Efloat    ********************/
Efloat::Efloat(Double p1)
{
  double_ = p1;

}

Efloat::Efloat(const Efloat & other)
{
  double_ = other.double_;

}

Efloat &Efloat::operator=(const Efloat & other)
{
  Efloat tmp(other);
  swap(tmp);
  return *this;
}

void Efloat::swap(Efloat & other)
{
  std::swap(double_, other.double_);

}

Efloat::~Efloat()
{

}

void Efloat::accept(Visitor *v)
{
  v->visitEfloat(this);
}

Efloat *Efloat::clone() const
{
  return new Efloat(*this);
}



/********************   Echar    ********************/
Echar::Echar(Char p1)
{
  char_ = p1;

}

Echar::Echar(const Echar & other)
{
  char_ = other.char_;

}

Echar &Echar::operator=(const Echar & other)
{
  Echar tmp(other);
  swap(tmp);
  return *this;
}

void Echar::swap(Echar & other)
{
  std::swap(char_, other.char_);

}

Echar::~Echar()
{

}

void Echar::accept(Visitor *v)
{
  v->visitEchar(this);
}

Echar *Echar::clone() const
{
  return new Echar(*this);
}



/********************   Eunsigned    ********************/
Eunsigned::Eunsigned(Unsigned p1)
{
  unsigned_ = p1;

}

Eunsigned::Eunsigned(const Eunsigned & other)
{
  unsigned_ = other.unsigned_;

}

Eunsigned &Eunsigned::operator=(const Eunsigned & other)
{
  Eunsigned tmp(other);
  swap(tmp);
  return *this;
}

void Eunsigned::swap(Eunsigned & other)
{
  std::swap(unsigned_, other.unsigned_);

}

Eunsigned::~Eunsigned()
{

}

void Eunsigned::accept(Visitor *v)
{
  v->visitEunsigned(this);
}

Eunsigned *Eunsigned::clone() const
{
  return new Eunsigned(*this);
}



/********************   Elong    ********************/
Elong::Elong(Long p1)
{
  long_ = p1;

}

Elong::Elong(const Elong & other)
{
  long_ = other.long_;

}

Elong &Elong::operator=(const Elong & other)
{
  Elong tmp(other);
  swap(tmp);
  return *this;
}

void Elong::swap(Elong & other)
{
  std::swap(long_, other.long_);

}

Elong::~Elong()
{

}

void Elong::accept(Visitor *v)
{
  v->visitElong(this);
}

Elong *Elong::clone() const
{
  return new Elong(*this);
}



/********************   Eunsignlong    ********************/
Eunsignlong::Eunsignlong(UnsignedLong p1)
{
  unsignedlong_ = p1;

}

Eunsignlong::Eunsignlong(const Eunsignlong & other)
{
  unsignedlong_ = other.unsignedlong_;

}

Eunsignlong &Eunsignlong::operator=(const Eunsignlong & other)
{
  Eunsignlong tmp(other);
  swap(tmp);
  return *this;
}

void Eunsignlong::swap(Eunsignlong & other)
{
  std::swap(unsignedlong_, other.unsignedlong_);

}

Eunsignlong::~Eunsignlong()
{

}

void Eunsignlong::accept(Visitor *v)
{
  v->visitEunsignlong(this);
}

Eunsignlong *Eunsignlong::clone() const
{
  return new Eunsignlong(*this);
}



/********************   Ehexadec    ********************/
Ehexadec::Ehexadec(Hexadecimal p1)
{
  hexadecimal_ = p1;

}

Ehexadec::Ehexadec(const Ehexadec & other)
{
  hexadecimal_ = other.hexadecimal_;

}

Ehexadec &Ehexadec::operator=(const Ehexadec & other)
{
  Ehexadec tmp(other);
  swap(tmp);
  return *this;
}

void Ehexadec::swap(Ehexadec & other)
{
  std::swap(hexadecimal_, other.hexadecimal_);

}

Ehexadec::~Ehexadec()
{

}

void Ehexadec::accept(Visitor *v)
{
  v->visitEhexadec(this);
}

Ehexadec *Ehexadec::clone() const
{
  return new Ehexadec(*this);
}



/********************   Ehexaunsign    ********************/
Ehexaunsign::Ehexaunsign(HexUnsigned p1)
{
  hexunsigned_ = p1;

}

Ehexaunsign::Ehexaunsign(const Ehexaunsign & other)
{
  hexunsigned_ = other.hexunsigned_;

}

Ehexaunsign &Ehexaunsign::operator=(const Ehexaunsign & other)
{
  Ehexaunsign tmp(other);
  swap(tmp);
  return *this;
}

void Ehexaunsign::swap(Ehexaunsign & other)
{
  std::swap(hexunsigned_, other.hexunsigned_);

}

Ehexaunsign::~Ehexaunsign()
{

}

void Ehexaunsign::accept(Visitor *v)
{
  v->visitEhexaunsign(this);
}

Ehexaunsign *Ehexaunsign::clone() const
{
  return new Ehexaunsign(*this);
}



/********************   Ehexalong    ********************/
Ehexalong::Ehexalong(HexLong p1)
{
  hexlong_ = p1;

}

Ehexalong::Ehexalong(const Ehexalong & other)
{
  hexlong_ = other.hexlong_;

}

Ehexalong &Ehexalong::operator=(const Ehexalong & other)
{
  Ehexalong tmp(other);
  swap(tmp);
  return *this;
}

void Ehexalong::swap(Ehexalong & other)
{
  std::swap(hexlong_, other.hexlong_);

}

Ehexalong::~Ehexalong()
{

}

void Ehexalong::accept(Visitor *v)
{
  v->visitEhexalong(this);
}

Ehexalong *Ehexalong::clone() const
{
  return new Ehexalong(*this);
}



/********************   Ehexaunslong    ********************/
Ehexaunslong::Ehexaunslong(HexUnsLong p1)
{
  hexunslong_ = p1;

}

Ehexaunslong::Ehexaunslong(const Ehexaunslong & other)
{
  hexunslong_ = other.hexunslong_;

}

Ehexaunslong &Ehexaunslong::operator=(const Ehexaunslong & other)
{
  Ehexaunslong tmp(other);
  swap(tmp);
  return *this;
}

void Ehexaunslong::swap(Ehexaunslong & other)
{
  std::swap(hexunslong_, other.hexunslong_);

}

Ehexaunslong::~Ehexaunslong()
{

}

void Ehexaunslong::accept(Visitor *v)
{
  v->visitEhexaunslong(this);
}

Ehexaunslong *Ehexaunslong::clone() const
{
  return new Ehexaunslong(*this);
}



/********************   Eoctal    ********************/
Eoctal::Eoctal(Octal p1)
{
  octal_ = p1;

}

Eoctal::Eoctal(const Eoctal & other)
{
  octal_ = other.octal_;

}

Eoctal &Eoctal::operator=(const Eoctal & other)
{
  Eoctal tmp(other);
  swap(tmp);
  return *this;
}

void Eoctal::swap(Eoctal & other)
{
  std::swap(octal_, other.octal_);

}

Eoctal::~Eoctal()
{

}

void Eoctal::accept(Visitor *v)
{
  v->visitEoctal(this);
}

Eoctal *Eoctal::clone() const
{
  return new Eoctal(*this);
}



/********************   Eoctalunsign    ********************/
Eoctalunsign::Eoctalunsign(OctalUnsigned p1)
{
  octalunsigned_ = p1;

}

Eoctalunsign::Eoctalunsign(const Eoctalunsign & other)
{
  octalunsigned_ = other.octalunsigned_;

}

Eoctalunsign &Eoctalunsign::operator=(const Eoctalunsign & other)
{
  Eoctalunsign tmp(other);
  swap(tmp);
  return *this;
}

void Eoctalunsign::swap(Eoctalunsign & other)
{
  std::swap(octalunsigned_, other.octalunsigned_);

}

Eoctalunsign::~Eoctalunsign()
{

}

void Eoctalunsign::accept(Visitor *v)
{
  v->visitEoctalunsign(this);
}

Eoctalunsign *Eoctalunsign::clone() const
{
  return new Eoctalunsign(*this);
}



/********************   Eoctallong    ********************/
Eoctallong::Eoctallong(OctalLong p1)
{
  octallong_ = p1;

}

Eoctallong::Eoctallong(const Eoctallong & other)
{
  octallong_ = other.octallong_;

}

Eoctallong &Eoctallong::operator=(const Eoctallong & other)
{
  Eoctallong tmp(other);
  swap(tmp);
  return *this;
}

void Eoctallong::swap(Eoctallong & other)
{
  std::swap(octallong_, other.octallong_);

}

Eoctallong::~Eoctallong()
{

}

void Eoctallong::accept(Visitor *v)
{
  v->visitEoctallong(this);
}

Eoctallong *Eoctallong::clone() const
{
  return new Eoctallong(*this);
}



/********************   Eoctalunslong    ********************/
Eoctalunslong::Eoctalunslong(OctalUnsLong p1)
{
  octalunslong_ = p1;

}

Eoctalunslong::Eoctalunslong(const Eoctalunslong & other)
{
  octalunslong_ = other.octalunslong_;

}

Eoctalunslong &Eoctalunslong::operator=(const Eoctalunslong & other)
{
  Eoctalunslong tmp(other);
  swap(tmp);
  return *this;
}

void Eoctalunslong::swap(Eoctalunslong & other)
{
  std::swap(octalunslong_, other.octalunslong_);

}

Eoctalunslong::~Eoctalunslong()
{

}

void Eoctalunslong::accept(Visitor *v)
{
  v->visitEoctalunslong(this);
}

Eoctalunslong *Eoctalunslong::clone() const
{
  return new Eoctalunslong(*this);
}



/********************   Ecdouble    ********************/
Ecdouble::Ecdouble(CDouble p1)
{
  cdouble_ = p1;

}

Ecdouble::Ecdouble(const Ecdouble & other)
{
  cdouble_ = other.cdouble_;

}

Ecdouble &Ecdouble::operator=(const Ecdouble & other)
{
  Ecdouble tmp(other);
  swap(tmp);
  return *this;
}

void Ecdouble::swap(Ecdouble & other)
{
  std::swap(cdouble_, other.cdouble_);

}

Ecdouble::~Ecdouble()
{

}

void Ecdouble::accept(Visitor *v)
{
  v->visitEcdouble(this);
}

Ecdouble *Ecdouble::clone() const
{
  return new Ecdouble(*this);
}



/********************   Ecfloat    ********************/
Ecfloat::Ecfloat(CFloat p1)
{
  cfloat_ = p1;

}

Ecfloat::Ecfloat(const Ecfloat & other)
{
  cfloat_ = other.cfloat_;

}

Ecfloat &Ecfloat::operator=(const Ecfloat & other)
{
  Ecfloat tmp(other);
  swap(tmp);
  return *this;
}

void Ecfloat::swap(Ecfloat & other)
{
  std::swap(cfloat_, other.cfloat_);

}

Ecfloat::~Ecfloat()
{

}

void Ecfloat::accept(Visitor *v)
{
  v->visitEcfloat(this);
}

Ecfloat *Ecfloat::clone() const
{
  return new Ecfloat(*this);
}



/********************   Eclongdouble    ********************/
Eclongdouble::Eclongdouble(CLongDouble p1)
{
  clongdouble_ = p1;

}

Eclongdouble::Eclongdouble(const Eclongdouble & other)
{
  clongdouble_ = other.clongdouble_;

}

Eclongdouble &Eclongdouble::operator=(const Eclongdouble & other)
{
  Eclongdouble tmp(other);
  swap(tmp);
  return *this;
}

void Eclongdouble::swap(Eclongdouble & other)
{
  std::swap(clongdouble_, other.clongdouble_);

}

Eclongdouble::~Eclongdouble()
{

}

void Eclongdouble::accept(Visitor *v)
{
  v->visitEclongdouble(this);
}

Eclongdouble *Eclongdouble::clone() const
{
  return new Eclongdouble(*this);
}



/********************   Eint    ********************/
Eint::Eint(Integer p1)
{
  integer_ = p1;

}

Eint::Eint(const Eint & other)
{
  integer_ = other.integer_;

}

Eint &Eint::operator=(const Eint & other)
{
  Eint tmp(other);
  swap(tmp);
  return *this;
}

void Eint::swap(Eint & other)
{
  std::swap(integer_, other.integer_);

}

Eint::~Eint()
{

}

void Eint::accept(Visitor *v)
{
  v->visitEint(this);
}

Eint *Eint::clone() const
{
  return new Eint(*this);
}



/********************   Elonger    ********************/
Elonger::Elonger(Integer p1)
{
  integer_ = p1;

}

Elonger::Elonger(const Elonger & other)
{
  integer_ = other.integer_;

}

Elonger &Elonger::operator=(const Elonger & other)
{
  Elonger tmp(other);
  swap(tmp);
  return *this;
}

void Elonger::swap(Elonger & other)
{
  std::swap(integer_, other.integer_);

}

Elonger::~Elonger()
{

}

void Elonger::accept(Visitor *v)
{
  v->visitElonger(this);
}

Elonger *Elonger::clone() const
{
  return new Elonger(*this);
}



/********************   Edouble    ********************/
Edouble::Edouble(Double p1)
{
  double_ = p1;

}

Edouble::Edouble(const Edouble & other)
{
  double_ = other.double_;

}

Edouble &Edouble::operator=(const Edouble & other)
{
  Edouble tmp(other);
  swap(tmp);
  return *this;
}

void Edouble::swap(Edouble & other)
{
  std::swap(double_, other.double_);

}

Edouble::~Edouble()
{

}

void Edouble::accept(Visitor *v)
{
  v->visitEdouble(this);
}

Edouble *Edouble::clone() const
{
  return new Edouble(*this);
}



/********************   Especial    ********************/
Especial::Especial(Exp *p1)
{
  exp_ = p1;

}

Especial::Especial(const Especial & other)
{
  exp_ = other.exp_->clone();

}

Especial &Especial::operator=(const Especial & other)
{
  Especial tmp(other);
  swap(tmp);
  return *this;
}

void Especial::swap(Especial & other)
{
  std::swap(exp_, other.exp_);

}

Especial::~Especial()
{
  delete(exp_);

}

void Especial::accept(Visitor *v)
{
  v->visitEspecial(this);
}

Especial *Especial::clone() const
{
  return new Especial(*this);
}



/********************   Address    ********************/
Address::Address()
{

}

Address::Address(const Address & other)
{

}

Address &Address::operator=(const Address & other)
{
  Address tmp(other);
  swap(tmp);
  return *this;
}

void Address::swap(Address & other)
{

}

Address::~Address()
{

}

void Address::accept(Visitor *v)
{
  v->visitAddress(this);
}

Address *Address::clone() const
{
  return new Address(*this);
}



/********************   Indirection    ********************/
Indirection::Indirection()
{

}

Indirection::Indirection(const Indirection & other)
{

}

Indirection &Indirection::operator=(const Indirection & other)
{
  Indirection tmp(other);
  swap(tmp);
  return *this;
}

void Indirection::swap(Indirection & other)
{

}

Indirection::~Indirection()
{

}

void Indirection::accept(Visitor *v)
{
  v->visitIndirection(this);
}

Indirection *Indirection::clone() const
{
  return new Indirection(*this);
}



/********************   Plus    ********************/
Plus::Plus()
{

}

Plus::Plus(const Plus & other)
{

}

Plus &Plus::operator=(const Plus & other)
{
  Plus tmp(other);
  swap(tmp);
  return *this;
}

void Plus::swap(Plus & other)
{

}

Plus::~Plus()
{

}

void Plus::accept(Visitor *v)
{
  v->visitPlus(this);
}

Plus *Plus::clone() const
{
  return new Plus(*this);
}



/********************   Negative    ********************/
Negative::Negative()
{

}

Negative::Negative(const Negative & other)
{

}

Negative &Negative::operator=(const Negative & other)
{
  Negative tmp(other);
  swap(tmp);
  return *this;
}

void Negative::swap(Negative & other)
{

}

Negative::~Negative()
{

}

void Negative::accept(Visitor *v)
{
  v->visitNegative(this);
}

Negative *Negative::clone() const
{
  return new Negative(*this);
}



/********************   Complement    ********************/
Complement::Complement()
{

}

Complement::Complement(const Complement & other)
{

}

Complement &Complement::operator=(const Complement & other)
{
  Complement tmp(other);
  swap(tmp);
  return *this;
}

void Complement::swap(Complement & other)
{

}

Complement::~Complement()
{

}

void Complement::accept(Visitor *v)
{
  v->visitComplement(this);
}

Complement *Complement::clone() const
{
  return new Complement(*this);
}



/********************   Logicalneg    ********************/
Logicalneg::Logicalneg()
{

}

Logicalneg::Logicalneg(const Logicalneg & other)
{

}

Logicalneg &Logicalneg::operator=(const Logicalneg & other)
{
  Logicalneg tmp(other);
  swap(tmp);
  return *this;
}

void Logicalneg::swap(Logicalneg & other)
{

}

Logicalneg::~Logicalneg()
{

}

void Logicalneg::accept(Visitor *v)
{
  v->visitLogicalneg(this);
}

Logicalneg *Logicalneg::clone() const
{
  return new Logicalneg(*this);
}



/********************   Assign    ********************/
Assign::Assign()
{

}

Assign::Assign(const Assign & other)
{

}

Assign &Assign::operator=(const Assign & other)
{
  Assign tmp(other);
  swap(tmp);
  return *this;
}

void Assign::swap(Assign & other)
{

}

Assign::~Assign()
{

}

void Assign::accept(Visitor *v)
{
  v->visitAssign(this);
}

Assign *Assign::clone() const
{
  return new Assign(*this);
}



/********************   AssignMul    ********************/
AssignMul::AssignMul()
{

}

AssignMul::AssignMul(const AssignMul & other)
{

}

AssignMul &AssignMul::operator=(const AssignMul & other)
{
  AssignMul tmp(other);
  swap(tmp);
  return *this;
}

void AssignMul::swap(AssignMul & other)
{

}

AssignMul::~AssignMul()
{

}

void AssignMul::accept(Visitor *v)
{
  v->visitAssignMul(this);
}

AssignMul *AssignMul::clone() const
{
  return new AssignMul(*this);
}



/********************   AssignDiv    ********************/
AssignDiv::AssignDiv()
{

}

AssignDiv::AssignDiv(const AssignDiv & other)
{

}

AssignDiv &AssignDiv::operator=(const AssignDiv & other)
{
  AssignDiv tmp(other);
  swap(tmp);
  return *this;
}

void AssignDiv::swap(AssignDiv & other)
{

}

AssignDiv::~AssignDiv()
{

}

void AssignDiv::accept(Visitor *v)
{
  v->visitAssignDiv(this);
}

AssignDiv *AssignDiv::clone() const
{
  return new AssignDiv(*this);
}



/********************   AssignMod    ********************/
AssignMod::AssignMod()
{

}

AssignMod::AssignMod(const AssignMod & other)
{

}

AssignMod &AssignMod::operator=(const AssignMod & other)
{
  AssignMod tmp(other);
  swap(tmp);
  return *this;
}

void AssignMod::swap(AssignMod & other)
{

}

AssignMod::~AssignMod()
{

}

void AssignMod::accept(Visitor *v)
{
  v->visitAssignMod(this);
}

AssignMod *AssignMod::clone() const
{
  return new AssignMod(*this);
}



/********************   AssignAdd    ********************/
AssignAdd::AssignAdd()
{

}

AssignAdd::AssignAdd(const AssignAdd & other)
{

}

AssignAdd &AssignAdd::operator=(const AssignAdd & other)
{
  AssignAdd tmp(other);
  swap(tmp);
  return *this;
}

void AssignAdd::swap(AssignAdd & other)
{

}

AssignAdd::~AssignAdd()
{

}

void AssignAdd::accept(Visitor *v)
{
  v->visitAssignAdd(this);
}

AssignAdd *AssignAdd::clone() const
{
  return new AssignAdd(*this);
}



/********************   AssignSub    ********************/
AssignSub::AssignSub()
{

}

AssignSub::AssignSub(const AssignSub & other)
{

}

AssignSub &AssignSub::operator=(const AssignSub & other)
{
  AssignSub tmp(other);
  swap(tmp);
  return *this;
}

void AssignSub::swap(AssignSub & other)
{

}

AssignSub::~AssignSub()
{

}

void AssignSub::accept(Visitor *v)
{
  v->visitAssignSub(this);
}

AssignSub *AssignSub::clone() const
{
  return new AssignSub(*this);
}



/********************   AssignLeft    ********************/
AssignLeft::AssignLeft()
{

}

AssignLeft::AssignLeft(const AssignLeft & other)
{

}

AssignLeft &AssignLeft::operator=(const AssignLeft & other)
{
  AssignLeft tmp(other);
  swap(tmp);
  return *this;
}

void AssignLeft::swap(AssignLeft & other)
{

}

AssignLeft::~AssignLeft()
{

}

void AssignLeft::accept(Visitor *v)
{
  v->visitAssignLeft(this);
}

AssignLeft *AssignLeft::clone() const
{
  return new AssignLeft(*this);
}



/********************   AssignRight    ********************/
AssignRight::AssignRight()
{

}

AssignRight::AssignRight(const AssignRight & other)
{

}

AssignRight &AssignRight::operator=(const AssignRight & other)
{
  AssignRight tmp(other);
  swap(tmp);
  return *this;
}

void AssignRight::swap(AssignRight & other)
{

}

AssignRight::~AssignRight()
{

}

void AssignRight::accept(Visitor *v)
{
  v->visitAssignRight(this);
}

AssignRight *AssignRight::clone() const
{
  return new AssignRight(*this);
}



/********************   AssignAnd    ********************/
AssignAnd::AssignAnd()
{

}

AssignAnd::AssignAnd(const AssignAnd & other)
{

}

AssignAnd &AssignAnd::operator=(const AssignAnd & other)
{
  AssignAnd tmp(other);
  swap(tmp);
  return *this;
}

void AssignAnd::swap(AssignAnd & other)
{

}

AssignAnd::~AssignAnd()
{

}

void AssignAnd::accept(Visitor *v)
{
  v->visitAssignAnd(this);
}

AssignAnd *AssignAnd::clone() const
{
  return new AssignAnd(*this);
}



/********************   AssignXor    ********************/
AssignXor::AssignXor()
{

}

AssignXor::AssignXor(const AssignXor & other)
{

}

AssignXor &AssignXor::operator=(const AssignXor & other)
{
  AssignXor tmp(other);
  swap(tmp);
  return *this;
}

void AssignXor::swap(AssignXor & other)
{

}

AssignXor::~AssignXor()
{

}

void AssignXor::accept(Visitor *v)
{
  v->visitAssignXor(this);
}

AssignXor *AssignXor::clone() const
{
  return new AssignXor(*this);
}



/********************   AssignOr    ********************/
AssignOr::AssignOr()
{

}

AssignOr::AssignOr(const AssignOr & other)
{

}

AssignOr &AssignOr::operator=(const AssignOr & other)
{
  AssignOr tmp(other);
  swap(tmp);
  return *this;
}

void AssignOr::swap(AssignOr & other)
{

}

AssignOr::~AssignOr()
{

}

void AssignOr::accept(Visitor *v)
{
  v->visitAssignOr(this);
}

AssignOr *AssignOr::clone() const
{
  return new AssignOr(*this);
}




/********************   ListExternal_declaration    ********************/

void ListExternal_declaration::accept(Visitor *v)
{
  v->visitListExternal_declaration(this);
}


ListExternal_declaration *ListExternal_declaration::clone() const
{
  return new ListExternal_declaration(*this);
}


/********************   ListDec    ********************/

void ListDec::accept(Visitor *v)
{
  v->visitListDec(this);
}


ListDec *ListDec::clone() const
{
  return new ListDec(*this);
}


/********************   ListDeclaration_specifier    ********************/

void ListDeclaration_specifier::accept(Visitor *v)
{
  v->visitListDeclaration_specifier(this);
}


ListDeclaration_specifier *ListDeclaration_specifier::clone() const
{
  return new ListDeclaration_specifier(*this);
}


/********************   ListInit_declarator    ********************/

void ListInit_declarator::accept(Visitor *v)
{
  v->visitListInit_declarator(this);
}


ListInit_declarator *ListInit_declarator::clone() const
{
  return new ListInit_declarator(*this);
}


/********************   ListStruct_dec    ********************/

void ListStruct_dec::accept(Visitor *v)
{
  v->visitListStruct_dec(this);
}


ListStruct_dec *ListStruct_dec::clone() const
{
  return new ListStruct_dec(*this);
}


/********************   ListSpec_qual    ********************/

void ListSpec_qual::accept(Visitor *v)
{
  v->visitListSpec_qual(this);
}


ListSpec_qual *ListSpec_qual::clone() const
{
  return new ListSpec_qual(*this);
}


/********************   ListStruct_declarator    ********************/

void ListStruct_declarator::accept(Visitor *v)
{
  v->visitListStruct_declarator(this);
}


ListStruct_declarator *ListStruct_declarator::clone() const
{
  return new ListStruct_declarator(*this);
}


/********************   ListEnumerator    ********************/

void ListEnumerator::accept(Visitor *v)
{
  v->visitListEnumerator(this);
}


ListEnumerator *ListEnumerator::clone() const
{
  return new ListEnumerator(*this);
}


/********************   ListType_qualifier    ********************/

void ListType_qualifier::accept(Visitor *v)
{
  v->visitListType_qualifier(this);
}


ListType_qualifier *ListType_qualifier::clone() const
{
  return new ListType_qualifier(*this);
}


/********************   ListIdent    ********************/

void ListIdent::accept(Visitor *v)
{
  v->visitListIdent(this);
}


ListIdent *ListIdent::clone() const
{
  return new ListIdent(*this);
}


/********************   ListStm    ********************/

void ListStm::accept(Visitor *v)
{
  v->visitListStm(this);
}


ListStm *ListStm::clone() const
{
  return new ListStm(*this);
}


/********************   ListExp    ********************/

void ListExp::accept(Visitor *v)
{
  v->visitListExp(this);
}


ListExp *ListExp::clone() const
{
  return new ListExp(*this);
}




